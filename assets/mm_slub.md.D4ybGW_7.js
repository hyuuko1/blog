import{_ as i,c as a,o as n,aj as l}from"./chunks/framework.CcbH9oJh.js";const E=JSON.parse('{"title":"SLUB 内存分配器","description":"","frontmatter":{"head":[["meta",{"property":"og:title","content":"SLUB 内存分配器 | Blog"}]]},"headers":[],"relativePath":"mm/slub.md","filePath":"mm/slub.md","lastUpdated":1761828946000}'),p={name:"mm/slub.md"};function e(h,s,t,k,r,c){return n(),a("div",null,s[0]||(s[0]=[l(`<h1 id="slub-内存分配器" tabindex="-1">SLUB 内存分配器 <a class="header-anchor" href="#slub-内存分配器" aria-label="Permalink to “SLUB 内存分配器”">​</a></h1><h2 id="参考" tabindex="-1">参考 <a class="header-anchor" href="#参考" aria-label="Permalink to “参考”">​</a></h2><p>按顺序看完这 4 篇（实际上讲的都是 slub），我写的基本就不用看了（</p><ol><li><a href="https://zhuanlan.zhihu.com/p/619560125" target="_blank" rel="noreferrer">细节拉满，80 张图带你一步一步推演 slab 内存池的设计与实现 - 知乎</a></li><li><a href="https://zhuanlan.zhihu.com/p/621239181" target="_blank" rel="noreferrer">从内核源码看 slab 内存池的创建初始化流程 - 知乎</a></li><li><a href="https://zhuanlan.zhihu.com/p/626883293" target="_blank" rel="noreferrer">深入理解 slab cache 内存分配全链路实现 - 知乎</a></li><li><a href="https://zhuanlan.zhihu.com/p/632323986" target="_blank" rel="noreferrer">深度解析 slab 内存池回收内存以及销毁全流程 - 知乎</a></li></ol><p>其他</p><ul><li><a href="http://www.wowotech.net/memory_management/427.html" target="_blank" rel="noreferrer">SLUB DEBUG 原理</a></li></ul><h2 id="概览" tabindex="-1">概览 <a class="header-anchor" href="#概览" aria-label="Permalink to “概览”">​</a></h2><ul><li>SLAB (已废弃)</li><li>SLOB (Simple List Of Blocks, 已废弃) 适用于小内存的嵌入式设备。 从这个 <a href="https://lore.kernel.org/lkml/20221121171202.22080-1-vbabka@suse.cz/" target="_blank" rel="noreferrer">[PATCH 00/12] Introduce CONFIG_SLUB_TINY and deprecate SLOB - Vlastimil Babka</a> 开始弃用了 SLOB，并为小内存场景引入了 <code>CONFIG_SLUB_TINY</code>。</li><li>SLUB 适用于大内存 <a href="https://lore.kernel.org/linux-mm/20230401094658.11146-1-vbabka@suse.cz/" target="_blank" rel="noreferrer">[PATCH] mm: remove all the slab allocators - Vlastimil Babka</a> 在 20230401 尝试废弃（</li></ul><p>slab 内存池的使用场景：分配和释放小内存，比如一些数据结构对象。</p><p>slab 首先会向伙伴系统一次性申请一个或者多个物理内存页面，正是这些物理内存页组成了 slab 内存池。</p><p>随后 slab 内存池会将这些连续的物理内存页面划分成多个大小相同的小内存块出来，同一种 slab 内存池下，划分出来的小内存块尺寸是一样的。内核会针对不同尺寸的小内存分配需求，预先创建出多个 slab 内存池出来。分配或释放对象时，直接从相应的 slab 内存池申请或释放，避免了链路比较长的内存分配与释放过程，极大地提升了性能。</p><ol><li>解决内碎片问题。</li><li>利用局部性。slab 会优先分配之前刚释放的对象。该对象可能还在 cpu cache 里。</li><li>伙伴系统的调用链路长，相关的指令和数据会将一些频繁使用的指令和数据从 L1Cache 挤出去。slab 对象池调用链路短，L1Cache 污染小。</li></ol><p>SLAB 分配器的核心思想是：为每种对象类型创建一个内存缓存 <code>struct kmem_cache</code>，每个内存缓存由多个大块组成，一个大块是一个或多个连续的物理页。</p><p>为了方便使用，块分配器在初始化的时候创建了一些通用的内存缓存，对象的长度大多数是 2^n 字节，从 normal zone 分配的内存缓存的名称是 <code>kmalloc-&lt;size&gt;</code>，从 DMA zone 分配内存缓存的名称是 <code>dma-kmalloc-&lt;size&gt;</code>，执行命令<code>cat /proc/slabinfo</code> 可以看到这些通用的内存缓存。</p><p>使用通用的内存缓存的缺点是：块分配器需要找到一个对象的长度刚好大于或等于请求的内存长度的通用内存缓存，如果请求的内存长度和内存缓存的对象长度相差很远，浪费比较大，例如申请 36 字节，实际分配的内存长度是 64 字节，浪费了 28 字节。所以有时候使用者需要创建专用的内存缓存。</p><div class="language-cpp line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">kmalloc</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">size_t</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> size</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">gfp_t</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> flags</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> kfree</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> void</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">objp</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">struct</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> kmem_cache</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">kmem_cache_create</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> char</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">name</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">unsigned</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> int</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> size</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">unsigned</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> int</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> align</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">slab_flags_t</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> flags</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (*</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">ctor</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">))</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">kmem_cache_alloc</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">struct</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> kmem_cache</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">cachep</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">gfp_t</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> flags</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> kmem_cache_free</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">struct</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> kmem_cache</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">s</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">objp</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> kmem_cache_destroy</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">struct</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> kmem_cache</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">s</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> kmem_cache_shrink</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">struct</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> kmem_cache</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">s</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><h3 id="用户态接口和命令" tabindex="-1">用户态接口和命令 <a class="header-anchor" href="#用户态接口和命令" aria-label="Permalink to “用户态接口和命令”">​</a></h3><p><code>/proc/slabinfo</code></p><ul><li>statistics 是基本统计信息 <ul><li>active_objs 表示 slab cache 中已经被分配出去的对象个数</li><li>num_objs 表示 slab cache 中容纳的对象总数</li><li>objsize 表示对象的 object size ，单位为字节</li><li>objperslab 表示每个 slab 可以容纳的对象个数</li><li>pagesperslab 表示每个 slab 所需要的物理内存页个数</li></ul></li><li>tunables 是动态可调节参数。与 slub 没关系。 <ul><li>limit 表示在 slab 的实现中，slab cache 的 cpu 本地缓存 array_cache 最大可以容纳的对象个数</li><li>batchcount 表示当 array_cache 中缓存的对象不够时，需要一次性填充的空闲对象个数。</li></ul></li><li>slabdata 是总体信息 <ul><li>active_slabs 一列展示的 slab cache 中活跃的 slab 个数。</li><li>nums_slabs 一列展示的是 slab cache 中管理的 slab 总数</li></ul></li></ul><p><code>/sys/kernel/slab/&lt;cache_name&gt;/</code> 是详细信息。</p><p><code>/sys/kernel/debug/slab</code></p><p><code>/proc/meminfo</code> 的 Slab 一行，是 slab cache 占用的内存总量。</p><p><code>slabtop</code> 命令</p><p>kernel cmdline slub_debug</p><h2 id="数据结构" tabindex="-1">数据结构 <a class="header-anchor" href="#数据结构" aria-label="Permalink to “数据结构”">​</a></h2><div class="language-cpp line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">struct</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> kmem_cache</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	struct</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> kmem_cache_cpu</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> __percpu </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">cpu_slab;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">	/* percpu slab 缓存 */</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">	/* 用于设置 slab 的一些特性，比如：按照什么方式对齐，是否需要毒化等 */</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">	slab_flags_t</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> flags;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	unsigned</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> long</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> min_partial;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">	/* 控制每个 node 的 partial slab 数量 */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	unsigned</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> size;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">		/* 对象真实大小，包含 read zone 等填充区域 */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	unsigned</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> object_size;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">	/* 对象原始大小，不包含填充区域 */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	struct</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> reciprocal_value</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> reciprocal_size;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	unsigned</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> offset;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">		/* freepointer 在对象中的偏移 */</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	unsigned</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> cpu_partial;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">	/* 控制每个 cpu 的 partial slab 里的空闲 object 数量 */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	unsigned</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> cpu_partial_slabs;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">	/* 控制每个 cpu 的 partial slab 数量 */</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">	/* 最优的阶数和对象数。高 16 位是物理页面阶数，低 16 位是能容纳的对象数。</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">	   最优是指：slab 使用 oo&gt;&gt;16 个物理页面时，剩余没用到的空间最小，利用率最大 */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	struct</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> kmem_cache_order_objects</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> oo;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">	/* slab 最少需要的物理页面的阶数（能容纳一个对象即可），以及能容纳的对象数。</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">	   内核最开始，会按照 oo 的阶数来向伙伴系统申请物理页面，长时间运行以后，内存碎片化，</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">	   分配连续页很难成功，就会按 min 的阶数来申请 */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	struct</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> kmem_cache_order_objects</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> min;</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">	gfp_t</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> allocflags;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">		/* 每次分配物理页面时用的 flag */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> refcount;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">			/* kmem_cache 可能有别名的情况 */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	void</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (*ctor)(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">object</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">	/* 对象的构造函数 */</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">	/* object_size 按照 word size 对齐之后的大小，</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">	   如果我们设置了SLAB_RED_ZONE，也会包括对象右侧 red zone 区域的大小 */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	unsigned</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> inuse;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	unsigned</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> align;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">		/* object 对其 */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	unsigned</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> red_left_pad;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">	/* 左侧 redzone 大小 */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	const</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> char</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">name;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">		/* /proc/slabinfo 的 name 那一列 */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	struct</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> list_head</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> list;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">		/* 作为链表成员，挂在链表 slab_caches 上 */</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	struct</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> kobject</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> kobj;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">		/* For sysfs */</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">	/*</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">	 * Defragmentation by allocating from a remote node.</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">	 */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	unsigned</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> remote_node_defrag_ratio;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">	/* 所有 node 的对象链表 */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	struct</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> kmem_cache_node</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">node[MAX_NUMNODES];</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/* per-cpu slab */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">struct</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> kmem_cache_cpu</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	union</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">		struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">			/* 下一个可用 object 的地址，为什么是 ** ？ */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">			void</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> **</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">freelist;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">			/* 可以看作是 cpu 的 id。</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">			如果被抢占，抢占前后 cpu 变了，这个可以用来判断 */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">			unsigned</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> long</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> tid;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">		};</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">		/* 用于在 __update_cpu_freelist_fast() 里进行 cmpxchg128 */</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">		freelist_aba_t</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> freelist_tid;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	};</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	struct</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> slab</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">slab;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">	/* 每次都是从这个 slab 分配 object */</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">	/* 一个 slab 链表，存放着“部分空闲”的 slab。</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">	如果 kmem_cache_cpu-&gt;slab 空了，就会从该链表中取出一个 slab */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	struct</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> slab</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">partial;</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">	local_lock_t</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> lock;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">	/* Protects the fields above */</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/* per-node slab */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">struct</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> kmem_cache_node</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">	spinlock_t</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> list_lock;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	unsigned</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> long</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> nr_partial;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">	/* node 内的“部分空闲”的 slab 的数量 */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	struct</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> list_head</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> partial;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">	/* node 内的“部分空闲”的 slab 链表 */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#ifdef</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> CONFIG_SLUB_DEBUG</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">	atomic_long_t</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> nr_slabs;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">		/* node 内的 slab 数量 */</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">	atomic_long_t</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> total_objects;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">	/* node 内的 object 总数 */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	struct</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> list_head</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> full;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">		/* node 内的已经分配完毕的 slab 链表 */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#endif</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/* slab 由 2^n 个连续物理页组成。如果 n&gt;0 则是一个复合页。</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   struct slab 是从 struct page 中剥离出来的。</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   https://lore.kernel.org/linux-mm/20211004134650.4031813-1-willy@infradead.org/ */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">struct</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> slab</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">	/*  */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	unsigned</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> long</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> __page_flags;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	struct</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> kmem_cache</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">slab_cache;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">	/* slab 所属的 kmem_cache */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	union</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">		struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">			union</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">				/* 挂在 kmem_cache_node 的 partial 链表上 */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">				struct</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> list_head</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> slab_list;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">				/* 挂在 kmem_cache_cpu 的 partial 单向链表上 */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">				struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">					struct</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> slab</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">next;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">					int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> slabs;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">	/* Nr of slabs left */</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">				};</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">			};</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">			/* Double-word boundary */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">			union</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">				struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">					/* 指向第一个空闲对象。当 slab 放进 kmem_cache_cpu 中时，</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">					会赋值给 kmem_cache_cpu-&gt;freelist。然后该 freelist 被置 0 */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">					void</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">freelist;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">					union</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">						unsigned</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> long</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> counters;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">						struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">							/* 已分配对象的数量 */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">							unsigned</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> inuse:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">16</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">							/* 对象的数量 */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">							unsigned</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> objects:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">15</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">							/* 如果在 kmem_cache_cpu 中，标记为冻结状态。</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">							反之，处于 kmem_cache_node 的 partial 链表中 */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">							unsigned</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> frozen:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">						};</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">					};</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">				};</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">				/* 用于在 __update_freelist_fast() 里进行 cmpxchg128 */</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">				freelist_aba_t</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> freelist_counter;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">			};</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">		};</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">		/* 在创建内存缓存的时候，如果指定标志位 SLAB_TYPESAFE_BY_RCU，要求使用 RCU 延迟释放 slab，</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">		在调用函数 call_rcu 把释放 slab 的函数加入 RCU 回调函数队列的时候，需要 rcu_head */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">		struct</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> rcu_head</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> rcu_head;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	};</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	unsigned</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> __page_type;</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">	atomic_t</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> __page_refcount;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	unsigned</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> long</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> obj_exts;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br><span class="line-number">52</span><br><span class="line-number">53</span><br><span class="line-number">54</span><br><span class="line-number">55</span><br><span class="line-number">56</span><br><span class="line-number">57</span><br><span class="line-number">58</span><br><span class="line-number">59</span><br><span class="line-number">60</span><br><span class="line-number">61</span><br><span class="line-number">62</span><br><span class="line-number">63</span><br><span class="line-number">64</span><br><span class="line-number">65</span><br><span class="line-number">66</span><br><span class="line-number">67</span><br><span class="line-number">68</span><br><span class="line-number">69</span><br><span class="line-number">70</span><br><span class="line-number">71</span><br><span class="line-number">72</span><br><span class="line-number">73</span><br><span class="line-number">74</span><br><span class="line-number">75</span><br><span class="line-number">76</span><br><span class="line-number">77</span><br><span class="line-number">78</span><br><span class="line-number">79</span><br><span class="line-number">80</span><br><span class="line-number">81</span><br><span class="line-number">82</span><br><span class="line-number">83</span><br><span class="line-number">84</span><br><span class="line-number">85</span><br><span class="line-number">86</span><br><span class="line-number">87</span><br><span class="line-number">88</span><br><span class="line-number">89</span><br><span class="line-number">90</span><br><span class="line-number">91</span><br><span class="line-number">92</span><br><span class="line-number">93</span><br><span class="line-number">94</span><br><span class="line-number">95</span><br><span class="line-number">96</span><br><span class="line-number">97</span><br><span class="line-number">98</span><br><span class="line-number">99</span><br><span class="line-number">100</span><br><span class="line-number">101</span><br><span class="line-number">102</span><br><span class="line-number">103</span><br><span class="line-number">104</span><br><span class="line-number">105</span><br><span class="line-number">106</span><br><span class="line-number">107</span><br><span class="line-number">108</span><br><span class="line-number">109</span><br><span class="line-number">110</span><br><span class="line-number">111</span><br><span class="line-number">112</span><br><span class="line-number">113</span><br><span class="line-number">114</span><br><span class="line-number">115</span><br><span class="line-number">116</span><br><span class="line-number">117</span><br><span class="line-number">118</span><br><span class="line-number">119</span><br><span class="line-number">120</span><br><span class="line-number">121</span><br><span class="line-number">122</span><br><span class="line-number">123</span><br><span class="line-number">124</span><br><span class="line-number">125</span><br><span class="line-number">126</span><br></div></div><ol><li><code>kmem_cache_create()</code> 为特定大小的对象创建一个 <code>struct kmem_cache</code></li><li>一个 <code>struct kmem_cache</code> 管理着许多 <code>struct slab</code>。通过 <code>struct kmem_cache_node</code> 和 <code>struct kmem_cache_cpu</code> 来管理。</li><li>一个 <code>struct slab</code> 描述了 2^n 个连续物理页。存储着许多 object。 乍一看，“描述了 2^n 个连续物理页”，这不就是起到了 struct page 或 compound page 的作用吗？实际上，在 v5.17 之前的内核，就是用 <code>struct page</code> 来管理这些 object，现在的 <code>struct slab</code> 就是从 <code>struct page</code> 中剥离出的。</li></ol><p>SLUB 分配器在创建内存缓存的时候计算了两种 slab 长度：最优 slab 和最小 slab。最优 slab 是剩余部分比例最小的 slab，最小 slab 只需要足够存放一个对象。当设备长时间运行以后，内存碎片化，分配连续物理页很难成功，如果分配最优 slab 失败，就分配最小 slab。</p><p>每个 slab 由一个或多个连续的物理页组成，页的阶数是最优 slab 或最小 slab 的阶数，如果阶数大于 0，组成一个复合页。</p><p>分配流程简述：</p><ol><li>先从 percpu slab 缓存分配，如果当前有一个 slab 正在使用，并且有空闲对象，则分配。</li><li>否则，如果 percpu 的 partial 部分空闲链表不是空的，则取出第一个 slab，作为当前正在使用的 slab。</li><li>如果 percpu partial slab 链表是空的。从当前 node 的的部分空闲链表取出 slab，重填 per cpu 的部分空闲 slab 链表。</li><li>如果当前 node 以及其他 node 的部分空闲链表也是空的，则从伙伴系统分配物理页面，分配新的 slab。</li></ol><p><code>kmem_cache</code> 实例的成员 <code>remote_node_defrag_ratio</code> 称为远程节点反碎片比例，用来控制从远程节点借用部分空闲 slab 和从本地节点取部分空闲 slab 的比例，值越小，从本地节点取部分空闲 slab 的倾向越大。默认值是 1000，可以通过文件 <code>/sys/kernel/slab/&lt;内存缓存名称&gt;/remote_node_defrag_ratio</code> 设置某个内存缓存的远程节点反碎片比例，用户设置的范围是 [0, 100]，内存缓存保存的比例值是乘以 10 以后的值。</p><p>释放对象：</p><ol><li>如果释放对象时，发现，当前对象所属的 slab 之前没有空闲对象（也就是说，释放当前对象，会使得该 slab 成为部分空闲 slab），并且，没有 frozen 在 percpu slab 缓存中，就会把该 slab 放在当前 cpu 的部分空闲 slab 链表中。</li><li>如果该链表总数超过限制 <code>kmem_cache.cpu_partial</code>，则将链表中的所有 slab 归还到当前 node 的部分空闲 slab 链表中。</li></ol><p>这种做法的好处是：把空闲对象非常少的 slab 放在每处理器空闲 slab 链表中，优先从空闲对象非常少的 slab 分配对象，减少内存浪费。</p><h3 id="对-slab-的管理" tabindex="-1">对 slab 的管理 <a class="header-anchor" href="#对-slab-的管理" aria-label="Permalink to “对 slab 的管理”">​</a></h3><p>不同状态的 slab，会在 slab cache 中被不同的链表所管理，同时 slab cache 会控制管理链表中 slab 的个数以及链表中所缓存的空闲对象个数，防止它们无限制的增长。</p><ul><li>empty slab</li><li>partial slab</li><li>full slab</li></ul><h3 id="slab-内部-对-object-的管理" tabindex="-1">slab 内部，对 object 的管理 <a class="header-anchor" href="#slab-内部-对-object-的管理" aria-label="Permalink to “slab 内部，对 object 的管理”">​</a></h3><p>word size 对齐，在 x86_64 就是 8 字节。</p><p>为了应对内存读写越界的场景，于是在对象内存的周围插入了一段不可访问的内存区域，这些内存区域用特定的字节 0xbb 填充，当进程访问的到内存是 0xbb 时，表示已经越界访问了。这段内存区域在 slab 中的术语为 red zone，大家可以理解为红色警戒区域。</p><p>空闲对象用链表串起来。</p><h3 id="config-slub-debug" tabindex="-1"><code>CONFIG_SLUB_DEBUG</code> <a class="header-anchor" href="#config-slub-debug" aria-label="Permalink to “CONFIG_SLUB_DEBUG”">​</a></h3><p>SLAB_POISON，毒化 slab，在对象内存区域填充特定字节表示对象的特殊状态的行为</p><p>在 5.17 版本之前的内核中，都是以一个 struct page 结构来表示一个 slab，如果 slab 用的是多个物理页，那则使用 compound page 来表示 slab。 5.17 版本，考虑到 struct page 已经非常庞大复杂，将 slab 相关字段删除，转移到 struct slab。</p><div class="language-cpp line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/* DEBUG: Perform (expensive) checks on alloc/free */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#define</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> SLAB_CONSISTENCY_CHECKS</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">	__SLAB_FLAG_BIT</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(_SLAB_CONSISTENCY_CHECKS)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/* DEBUG: Red zone objs in a cache */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#define</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> SLAB_RED_ZONE</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">		__SLAB_FLAG_BIT</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(_SLAB_RED_ZONE)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/* DEBUG: Poison objects */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#define</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> SLAB_POISON</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">		__SLAB_FLAG_BIT</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(_SLAB_POISON)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/* DEBUG: Store the last owner for bug hunting */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#define</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> SLAB_STORE_USER</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">		__SLAB_FLAG_BIT</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(_SLAB_STORE_USER)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/* Trace allocations and frees */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#define</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> SLAB_TRACE</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">		__SLAB_FLAG_BIT</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(_SLAB_TRACE)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#ifdef</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> CONFIG_SLUB_DEBUG</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#define</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> SLAB_DEBUG_FLAGS</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (SLAB_RED_ZONE </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">|</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> SLAB_POISON </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">|</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> SLAB_STORE_USER </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">|</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> \\</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">			  SLAB_TRACE </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">|</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> SLAB_CONSISTENCY_CHECKS)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#else</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#define</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> SLAB_DEBUG_FLAGS</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (0)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#endif</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><ul class="contains-task-list"><li class="task-list-item"><input class="task-list-item-checkbox" disabled="" type="checkbox"> <code>CONFIG_SLUB_DEBUG_ON</code></li></ul><h2 id="代码分析" tabindex="-1">代码分析 <a class="header-anchor" href="#代码分析" aria-label="Permalink to “代码分析”">​</a></h2><h3 id="slab-allocator-体系的初始化" tabindex="-1">slab allocator 体系的初始化 <a class="header-anchor" href="#slab-allocator-体系的初始化" aria-label="Permalink to “slab allocator 体系的初始化”">​</a></h3><p>分配内存需要用到 <code>struct kmem_cache</code>，而创建 <code>struct kmem_cache</code> 也需要分配内存。</p><p>那内核第一个 kmem_cache 是如何被创建出来的呢？</p><div class="language-cpp line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/* 初始化 struct kmem_cache *kmem_cache */</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">start_kernel</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()-&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">mm_core_init</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()-&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">kmem_cache_init</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  create_boot_cache</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;kmem_cache_node&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)-&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">do_kmem_cache_create</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  slab_state </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> PARTIAL;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  create_boot_cache</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;kmem_cache&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)-&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">do_kmem_cache_create</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  kmem_cache </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> bootstrap</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">boot_kmem_cache);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  kmem_cache_node </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> bootstrap</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">boot_kmem_cache_node);</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  setup_kmalloc_cache_index_table</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">	/* 初始化 kmalloc_size_index 数组 */</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  create_kmalloc_caches</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    new_kmalloc_cache</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> /* 创建各种大小的 kmalloc-8 kmalloc-16 ... */</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    slab_state </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> UP;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  init_freelist_randomization</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">	/* 初始化 kmalloc_caches 二维数组 */</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/* 要等 sysfs 存在之后，才能创建 /sys/kenerl/slab/，所以才 late_initcall() ? */</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">late_initcall</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(slab_sysfs_init);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  /* initcall 是在 1 号内核线程中执行的，因此存在竞态条件，需要加锁 */</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  mutex_lock</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">slab_mutex);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  slab_kset </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> kset_create_and_add</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;slab&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">NULL</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, kernel_kobj);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  slab_state </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> FULL;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  /* 将在此之前未放进 /sys/kernel/slab/ 的全放进去 */</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  list_for_each_entry</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(s, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">slab_caches, list)</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    sysfs_slab_add</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  while</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (alias_list)</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    sysfs_slab_alias</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  mutex_unlock</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">slab_mutex);</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br></div></div><ul class="contains-task-list"><li class="task-list-item"><input class="task-list-item-checkbox" disabled="" type="checkbox"> 详细分析下 <code>kmem_cache_init()</code></li></ul><h3 id="kmem-cache-的创建" tabindex="-1">kmem_cache 的创建 <a class="header-anchor" href="#kmem-cache-的创建" aria-label="Permalink to “kmem_cache 的创建”">​</a></h3><p>在分配某种大小的内存前，需要先创建对应的 <code>struct kmem_cache</code> 实例。</p><p>如果对象可能被拷贝到用户态，应使用 <code>kmem_cache_create_usercopy()</code> 函数，指定内核对象内存布局区域中 <code>useroffset</code> 到 <code>usersize</code> 的这段内存区域可以被复制到用户空间中，其他区域则不可以。例如，ptrace 系统调用访问当前进程的 <code>task_struct</code> 时，就会限制访问区域。</p><p><code>slab_state</code> 全局变量，表示 slab allocator 的初始化状态。</p><div class="language-cpp line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/* 一个 kmem_cache_create_usercopy() 的例子 */</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">fork_init</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  task_struct_whitelist</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">useroffset, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">usersize);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  task_struct_cachep </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> kmem_cache_create_usercopy</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;task_struct&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, ... useroffset, usersize, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">NULL</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    __kmem_cache_create_args</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">__kmem_cache_create_args</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  mutex_lock</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">slab_mutex);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  /* 如果 CONFIG_DEBUG_VM=y 则做一些检查，大小应在 [8B, 4MB] 范围内，不能在 NMI,IRQ,SoftIRQ context */</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  kmem_cache_sanity_check</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(name, object_size);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  /* 尽可能复用现有的 kmem_cache，需要满足一些条件，比如对齐后的 objsize 相等，</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">     如果找到了，就无需创建新的了，只需创建别名，在 sysfs 创建符号链接，refcount++ */</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  s </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> __kmem_cache_alias</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">find_mergeable</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()) </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">sysfs_slab_alias</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    s-&gt;refcount</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  /* 创建新的 kmem_cache */</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  s </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> create_cache</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(cache_name, object_size, args, flags);</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    kmem_cache_zalloc</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(kmem_cache, GFP_KERNEL);</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    do_kmem_cache_create</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(s, name, object_size, args, flags);</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">      calculate_sizes</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">		/* 计算各种 size，包含了 object 内存布局的全部逻辑 */</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        size </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ALIGN</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(size, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">sizeof</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">));</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> /* word size 对齐 */</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">      set_cpu_partial</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">		/* 设置 cpu_partial 和 cpu_partial_slabs 限制 */</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">      init_kmem_cache_nodes</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">	/* 分配并初始化 kmem_cache_node */</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">      alloc_kmem_cache_cpus</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">	/* 分配并初始化 kmem_cache_cpu */</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">      sysfs_slab_add</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">		/* /sys/kernel/slab/&lt;cache_name&gt; */</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    s-&gt;refcount </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    list_add</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">s-&gt;list, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">slab_caches);</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> /* 放进全局 slab_caches 链表 */</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  mutex_unlock</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">slab_mutex);</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br></div></div><ul class="contains-task-list"><li class="task-list-item"><input class="task-list-item-checkbox" disabled="" type="checkbox"> <code>calculate_sizes()</code> 是如何计算各种 size 的？换个说法，object 的布局是啥样的？</li><li class="task-list-item"><input class="task-list-item-checkbox" disabled="" type="checkbox"> <code>calculate_order()</code> 是如何计算出最佳阶数的？</li></ul><p>kmem_cache 别名的例子：</p><div class="language-bash line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">lrwxrwxrwx</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">     -</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> root</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> 2024-10-27</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> 01:00</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> /sys/kernel/slab/io</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">         -</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> :0000064</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">lrwxrwxrwx</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">     -</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> root</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> 2024-10-27</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> 01:00</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> /sys/kernel/slab/iommu_iova</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> -</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> :0000064</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><ul class="contains-task-list"><li class="task-list-item"><input class="task-list-item-checkbox" disabled="" type="checkbox"> <code>:0000064</code> 这个是何时创建的？用 gdb do_kmem_cache_create 并没有找到 :0000064 这个 name。 猜测：只有当存在 alias 时，:0000064 这个 kobj 才会被创建。</li></ul><h3 id="分配对象" tabindex="-1">分配对象 <a class="header-anchor" href="#分配对象" aria-label="Permalink to “分配对象”">​</a></h3><p>根据 <code>kmalloc_noprof()</code> 的注释，<code>GFP_NOWAIT</code> 或 <code>GFP_ATOMIC</code> 不会睡眠，因此可以在中断上下文使用。</p><div class="language-cpp line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/* 注意，很多都是 inline 的，所以可以判断是否是常量，让编译器优化 */</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">kmalloc</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()-&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">kmalloc_noprof</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  /* 如果 size 是常量 */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">__builtin_constant_p</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(size) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> size)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    /* 大于 8KB，从伙伴系统分配复合页面 */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (size </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> KMALLOC_MAX_CACHE_SIZE) </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">__kmalloc_large_noprof</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(size)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    /* 否则从 kmem_cache 中分配 */</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    index </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> kmalloc_index</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(size);</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    __kmalloc_cache_noprof</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(kmalloc_caches[</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">kmalloc_type</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(flags, _RET_IP_)][index], ...);</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">      slab_alloc_node</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  /* size 不是常量 */</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  __kmalloc_noprof</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()-&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">__do_kmalloc_node</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    /* 大于 8KB，从伙伴系统分配复合页面 */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">unlikely</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(size </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> KMALLOC_MAX_CACHE_SIZE)) </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">__kmalloc_large_node_noprof</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    /* 否则选择一个 kmem_cache 从其中分配 */</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    s </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> kmalloc_slab</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(size, b, flags, caller);</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    slab_alloc_node</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(s, ...);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">kmem_cache_alloc</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()-&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">kmem_cache_alloc_noprof</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()-&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">slab_alloc_node</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">kmem_cache_alloc_bulk_noprof</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br></div></div><p>可以看到 <code>kmalloc()</code> 和 <code>kmem_cache_alloc()</code> 最终都会调用 <code>slab_alloc_node()</code></p><div class="language-cpp line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">slab_alloc_node</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()-&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">__slab_alloc_node</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  struct</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> kmem_cache_cpu</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">c </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> raw_cpu_ptr</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(s-&gt;cpu_slab);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  tid </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> READ_ONCE</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(c-&gt;tid);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  struct</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> slab</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">slab </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> c-&gt;slab;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  /* 如果 slab 内没有空闲对象，或者当前 slab 不在我们指定的 node 内，则走慢速路径 */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">unlikely</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">object </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">||</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> !</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">slab </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">||</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> !</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">node_match</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(slab, node))) </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">__slab_alloc</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  /* 否则，更新 freelist 让其指向下一个空闲对象，然后返回，分配成功。因为可能发生抢占，</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">     导致此时在另一个 cpu 上，所以用 cmpxchg，当 freelist 和 tid 与当前 cpu 的不同时，就 redo */</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  next_object </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> get_freepointer_safe</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(s, object);</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> /* TODO 为什么 get_freepointer_safe 这么复杂？ */</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  __update_cpu_freelist_fast</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/* 慢速路径 */</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">__slab_alloc</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  /* 此时可能发生过抢占，被调度到其他 cpu 上了，因此重新获取 kmem_cache_cpu。注意这里还会禁抢占 */</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  c </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> slub_get_cpu_ptr</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(s-&gt;cpu_slab);</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  ___slab_alloc</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">reread_slab:</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    slab </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> READ_ONCE</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(c-&gt;slab);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">slab) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">goto</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> new_slab;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    /* 前面都禁抢占了，这里为什么要禁本地中断？因为在中断上下文，可能分配内存导致 c-&gt;slab 发生变化 */</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    local_lock_irqsave</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">s-&gt;cpu_slab-&gt;lock, flags);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    /* 有可能发生中断后在中断上下文分配内存，导致 c-&gt;slab 变化 */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">unlikely</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(slab </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> c-&gt;slab))</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">      local_unlock_irqrestore</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">s-&gt;cpu_slab-&gt;lock, flags);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">      goto</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> reread_slab;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    /* 有可能发生中断后在中断上下文发生过内存分配/释放，使得 slab 又有空闲对象了 */</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    freelist </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> c-&gt;freelist;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (freelist) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">goto</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> load_freelist;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    /*  */</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    freelist </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> get_freelist</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(s, slab);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">load_freelist:</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    /* 更新 freelist 指向下一个空闲对象后，返回 */</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    ...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">new_slab:</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    /* 遍历 c-&gt;partial 单向 slab 链表 */</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    ... 如果有，则 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">goto</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> load_freelist;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">new_objects:</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    slab </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> get_partial</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(s, node, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">pc);</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> /* 从 kmem_cache_node 中获取 slab */</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  slub_put_cpu_ptr</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(s-&gt;cpu_slab);</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> /* 打开抢占 */</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br></div></div><p>两个 freelist 指针，相当于一个 slab 上有两个链表。</p><ul><li><code>struct kmem_cache_cpu</code> 的 freelist，申请内存时用的是这个。</li><li><code>struct slab</code> 的 freelist，释放内存时用的是这个。</li></ul><p>为什么这么设计？答：对于某个在 <code>struct kmem_cache_cpu</code> 上的 slab，可能有多个 cpu 同时在操作。一个 cpu 在申请该 slab 的 object，多个 cpu 在释放 object 到这个 slab 上。因此分成两个 freelist 指针。 虽然，如果只用一个 freelist，也就是一个链表，用 cmpxchg 的话，能无锁，但没必要。毕竟如果用两个链表，在 <code>__slab_alloc</code> 里更新 object 时连 cmpxchg 都不需要。</p><h3 id="释放对象" tabindex="-1">释放对象 <a class="header-anchor" href="#释放对象" aria-label="Permalink to “释放对象”">​</a></h3><p>以后有空再看</p>`,72)]))}const g=i(p,[["render",e]]);export{E as __pageData,g as default};
