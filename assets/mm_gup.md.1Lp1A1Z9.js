import{_ as i,c as a,o as l,al as e}from"./chunks/framework.CdzZEkix.js";const g=JSON.parse('{"title":"GUP (Get User Page)","description":"","frontmatter":{"head":[["meta",{"property":"og:title","content":"GUP (Get User Page) | Blog"}]]},"headers":[],"relativePath":"mm/gup.md","filePath":"mm/gup.md","lastUpdated":1763912647000}'),n={name:"mm/gup.md"};function p(t,s,r,h,k,o){return l(),a("div",null,[...s[0]||(s[0]=[e(`<h1 id="gup-get-user-page" tabindex="-1">GUP (Get User Page) <a class="header-anchor" href="#gup-get-user-page" aria-label="Permalink to “GUP (Get User Page)”">​</a></h1><ul><li><a href="https://docs.kernel.org/core-api/pin_user_pages.html" target="_blank" rel="noreferrer">pin_user_pages() and related calls — The Linux Kernel documentation</a></li><li><a href="https://cloud.tencent.com/developer/article/1681326" target="_blank" rel="noreferrer">宋宝华：论 Linux 的页迁移（Page Migration）完整版</a> GUP 和页迁移有关，这里也提到了 GUP</li><li><a href="https://lwn.net/Articles/787636/?utm_source=chatgpt.com" target="_blank" rel="noreferrer">get_user_pages(), pinned pages, and DAX [LWN.net]</a></li></ul><h2 id="gup-知识点一览" tabindex="-1">GUP 知识点一览 <a class="header-anchor" href="#gup-知识点一览" aria-label="Permalink to “GUP 知识点一览”">​</a></h2><p>这里做一下简要记录，后面的段落再详细剖析</p><p>核心作用：通过增加页面的引用计数 <code>page-&gt;_refcount</code>，来阻止内核内存管理子系统回收或移动这个页面。也就是，pin 住 folio。</p><p>那么，为什么要阻止回收和移动呢？场景：</p><ul><li>让用户空间内存安全地被设备 DMA。 <ul><li>为什么内核自身分配的 buffer 等内存被设备 DMA 前，无需 pin 呢？因为这些内存本就不会被回收或移动。</li><li>场景 <ul><li>MSG_ZEROCOPY <code>tcp_sendmsg_locked()-&gt;skb_zerocopy_iter_stream()-&gt;__zerocopy_sg_from_iter()-&gt;zerocopy_fill_skb_from_iter()-&gt;iov_iter_get_pages2()-&gt;__iov_iter_get_pages_alloc()-&gt;get_user_pages_fast()</code></li></ul></li></ul></li><li>让内核能够安全、正确、高效地直接访问用户空间内存。函数调用后，用户内存对应的 struct page 指针记录在 pages 数组内，在 unpin 之前，内核都可以通过 struct page 得到对应的直接映射地址，安全高效地访问。</li></ul><p>GUP 涉及到</p><ul><li>增加额外的引用计数</li><li>缺页处理</li></ul><p>还有一些杂项，有空写一下</p><ul><li><code>xxx_fast()</code> 不需要加锁。</li><li>与 huge pages 和 DAX 相关的，暂不讨论</li></ul><h2 id="核心流程" tabindex="-1">核心流程 <a class="header-anchor" href="#核心流程" aria-label="Permalink to “核心流程”">​</a></h2><p>最核心的流程在 <code>__get_user_pages_locked()-&gt;__get_user_pages()</code>，文字叙述下</p><ol><li>locked 参数用于指示：进入此函数前，是否已经 mmap_read_lock(mm) 获取了 mm-&gt;mmap_lock 读信号量 <ol><li>如果为 0，表明 caller 要求此函数获取锁</li><li>否则，表明 caller 已经获取锁了。此处检查是否真的获取了，没获取就会 WARN</li></ol></li><li>如果 FOLL_PIN，会设置 mm-&gt;flags MMF_HAS_PINNED。作用： <ol class="contains-task-list"><li>在 folio_needs_cow_for_dma() 中快速判断</li><li class="task-list-item"><input class="task-list-item-checkbox" disabled="" type="checkbox"> pte_is_pinned()</li></ol></li><li>循环 <code>__get_user_pages()</code></li></ol><h2 id="缺页异常处理" tabindex="-1">缺页异常处理 <a class="header-anchor" href="#缺页异常处理" aria-label="Permalink to “缺页异常处理”">​</a></h2><h3 id="为什么会涉及到-faultin-page-缺页处理" tabindex="-1">为什么会涉及到 <code>faultin_page()</code> 缺页处理 <a class="header-anchor" href="#为什么会涉及到-faultin-page-缺页处理" aria-label="Permalink to “为什么会涉及到 faultin_page() 缺页处理”">​</a></h3><p>GUP 的核心目标是：获取并固定用户虚拟地址对应的物理页，供内核或设备长期访问。但用虚拟地址对应的物理页可能并不存在于内存中：</p><ul><li>尚未分配</li><li>已 swap out</li><li>文件映射但未读入</li></ul><p>因此，要主动模拟缺页异常，进行处理。</p><h3 id="缺页处理时-遇到阻塞时的处理流程" tabindex="-1">缺页处理时，遇到阻塞时的处理流程 <a class="header-anchor" href="#缺页处理时-遇到阻塞时的处理流程" aria-label="Permalink to “缺页处理时，遇到阻塞时的处理流程”">​</a></h3><p>缺页处理过程中可能会阻塞</p><p>TODO 后续把这个补充到 <a href="./pagefault">pagefault</a></p><ul><li>如果设置了 <code>FOLL_UNLOCKABLE</code>，会影响 handle_mm_fault() 时的 fault_flags 参数： <ul><li>会带上 <code>FAULT_FLAG_ALLOW_RETRY</code>，允许返回 <code>VM_FAULT_RETRY</code>，</li><li>会带上 <code>FAULT_FLAG_KILLABLE</code>，允许被 kill</li></ul></li><li>如果设置了 <code>FOLL_NOWAIT</code>，会带上 <code>FAULT_FLAG_RETRY_NOWAIT</code> 使得遇到阻塞会直接失败</li></ul><p>这里只举两个 fault 的例子，</p><ol><li>filemap_fault()-&gt;lock_folio_maybe_drop_mmap()</li></ol><div class="language-cpp line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">lock_folio_maybe_drop_mmap</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  /*  */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">folio_trylock</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(folio))</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    /* 成功返回 */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (vmf-&gt;flags </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> FAULT_FLAG_RETRY_NOWAIT)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  /* 如果是第一次 retry，则 unlock mmap_lock 使得其他地方可以获取这锁，进行 io？ */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  *</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">fpin </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> maybe_unlock_mmap_for_io</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  /*  */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (vmf-&gt;flags </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> FAULT_FLAG_KILLABLE) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">__folio_lock_killable</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(folio)) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">fpin </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> NULL</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    release_fault_lock</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(vmf);</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> /* 没懂这里 */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  /* 获取锁，阻塞睡眠 */</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  __folio_lock</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(folio);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  /* 成功返回，但是已经释放了 mmap_lock 并且 fpin 指向了 pinned file，</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">     所以在 filemap_fault() 里是会 folio_unlock() goto out_retry 返回 VM_FAULT_RETRY 的 */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div><ol start="2"><li>do_swap_page()-&gt;folio_lock_or_retry() 也差不多</li></ol><p>如果阻塞了，会释放 mmap_lock，然后等到 folio unlock 的情况下返回 VM_FAULT_RETRY。</p><h2 id="如何防止被回收的" tabindex="-1">如何防止被回收的？ <a class="header-anchor" href="#如何防止被回收的" aria-label="Permalink to “如何防止被回收的？”">​</a></h2><p>在内存回收时，在完成 <code>shrink_folio_list()-&gt;try_to_unmap()</code> 移除所有进程页表映射，减少这些带来的 refcount 后，</p><ul><li>对于匿名页，<code>shrink_folio_list()-&gt;folio_ref_freeze()</code> 会返回 false</li><li>对于文件页，<code>shrink_folio_list()-&gt;__remove_mapping()-&gt;folio_ref_freeze()</code> 会返回 false</li></ul><h2 id="如何-pin-住内存不被移动的" tabindex="-1">如何 pin 住内存不被移动的？ <a class="header-anchor" href="#如何-pin-住内存不被移动的" aria-label="Permalink to “如何 pin 住内存不被移动的？”">​</a></h2><p><code>get/pin_user_pages()</code> 函数，当 pages 参数不为 NULL 时，都会 pin 内存。 如果 pages 参数是 NULL，则只保证触发缺页处理，不会去 pin 内存。</p><p>如何做到 pin 内存的？ try_grab_folio() 的 FOLL_GET/FOLL_PIN 都会增加额外的引用计数。</p><p>以内存规整流程时的页面迁移为例，检测到存在 unexpected references，就会 return -EAGAIN 不进行页面迁移。</p><div class="language-cpp line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">compact_zone</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  migrate_pages</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()-&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">migrate_pages_batch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()-&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">migrate_folios_move</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()-&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">migrate_folio_move</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    move_to_new_folio</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()-&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">migrate_folio</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()-&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">__migrate_folio</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">      /* detect unexpected references (e.g., GUP or other temporary references) */</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      expected_count </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> folio_expected_ref_count</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(src) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">      if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">folio_ref_count</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(src) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> expected_count)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        return</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> -</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">EAGAIN;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">      folio_mc_copy</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(dst, src);</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">      __folio_migrate_mapping</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><h2 id="foll-get-foll-pin-有何区别" tabindex="-1">FOLL_GET/FOLL_PIN 有何区别 <a class="header-anchor" href="#foll-get-foll-pin-有何区别" aria-label="Permalink to “FOLL_GET/FOLL_PIN 有何区别”">​</a></h2><p>FOLL_PIN 和 FOLL_GET 是互斥的，不能同时使用。</p><p>会影响 folio_maybe_dma_pinned() 的结果。</p><ul><li>对于 FOLL_PIN，一定返回 true；</li><li>对于 FOLL_GET，则是<strong>大概率</strong>返回 false，虽然小概率返回 true，但可以容忍这种小错误。</li></ul><hr><p><code>__get_user_pages()</code> 的注释，</p><p>返回成功 pin 的 page 数量，或者错误。 调用时必须持有 mmap_lock。 如果有 FOLL_UNLOCKABLE 但是没有 FOLL_NOWAIT，那么 mmap_lock 也许会被释放，此时 locked 会被置 0</p><p>遍历进程的页表，并为每个用户地址此时对应的 page 增加引用计数。 注意，该函数不能避免这种情况： 在此函数返回时，可能用户的其他线程就 unmap 了，导致用户没有映射该 page。</p><div class="language-cpp line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">__get_user_pages_locked</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">__get_user_pages</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  page </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> follow_page_mask</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">...</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    follow_page_pte</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      page </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> vm_normal_page</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(vma, address, pte);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      folio </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> page_folio</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(page);</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">      try_grab_folio</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(folio, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, flags);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  /* 如果返回的 page 是 NULL，就需要 faultin_page()，</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">     如果成功 faultin_page() 了，就 retry 重新 follow_xxx 得到 page */</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  faultin_page</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><h2 id="foll-longterm" tabindex="-1">FOLL_LONGTERM <a class="header-anchor" href="#foll-longterm" aria-label="Permalink to “FOLL_LONGTERM”">​</a></h2><p>FOLL_LONGTERM，其核心作用是为了防止长期 pin 时，一直不能移动，可能造成碎片化。</p><p>只有在用了 FOLL_PIN 时，才允许使用 FOLL_LONGTERM</p><p>根据我看的代码，传入 FOLL_LONGTERM 并没有增加页的固定计数，而是进行了 memalloc_pin_save() 和 check_and_migrate_movable_pages()，确保被 pin 的页面的 migratetype 都是 MIGRATE_UNMOVABLE 的，并且不在 ZONE_MOVABLE 内。 相关的函数有：</p><ol><li>collect_longterm_unpinnable_folios() 收集不可长期 pin 的 folios</li><li>folio_is_longterm_pinnable() 判断该 folio 是否是可以长期 pin 的</li><li>migrate_longterm_unpinnable_folios() 将不可长期 pin 的 folios，先进行 unpin，然后再 migrate_pages()将 folio 迁移，迁移的 target 由 alloc_migration_target()分配</li></ol><p>所以，何时应使用 FOLL_LONGTERM ? 我认为是当用户认为 pages 会被长期固定住时，需要使用 FOLL_LONGTERM 作为一个提示，让内核保证页面的 migratetype 都是 MIGRATE_UNMOVABLE 的，并且不在 ZONE_MOVABLE 内。 我的理由：这是为了防止长期的页面固定导致长期的内存碎片化。</p><p>vfio 和 vhost-vdpa 调用 pin_user_pages 时，都用了这个 flag， 因为是虚拟机的内存，肯定是会 pin 很久的。</p><h2 id="foll-unlockable" tabindex="-1">FOLL_UNLOCKABLE <a class="header-anchor" href="#foll-unlockable" aria-label="Permalink to “FOLL_UNLOCKABLE”">​</a></h2><p>关于 FOLL_UNLOCKABLE，允许 gup 的过程中在 faultin_page() 里因一些原因释放 mmap_lock。</p><ol><li>何时设置的？当用户调用的是 <code>pin_user_pages_unlocked()</code> 时</li><li>如何影响 handle_mm_fault() 的？根据 faultin_page() 的注释，如果有 FOLL_UNLOCKABLE 但是没有 FOLL_NOWAIT。就会使得 faultin_page() 里当 folio_trylock() 失败时（何种情况下会 folio 被 lock 了呢？文件页写回？），释放 mmap_lock 减少争用，并返回 VM_FAULT_RETRY 或 VM_FAULT_COMPLETED。如果真释放了，把 locked 改为 0。 具体释放的代码位置：<code>__folio_lock_or_retry()/maybe_unlock_mmap_for_io()/__folio_lock_or_retry()/lock_folio_maybe_drop_mmap()</code>。</li></ol><h2 id="pg-anon-exclusive" tabindex="-1">PG_anon_exclusive <a class="header-anchor" href="#pg-anon-exclusive" aria-label="Permalink to “PG_anon_exclusive”">​</a></h2><ol><li>PG_anon_exclusive 没搞懂。do_wp_page()-&gt;wp_can_reuse_anon_folio() 里，如果 folio_ref_count(folio) 不是 1，那就 return false？ 为什么这样判断？如果 gup 了，就不能 reuse 吗。 难道不应该是判断 mapcount，当确认只有一个 mapcount 时，就 reuse 吗？</li></ol><p><code>__folio_try_share_anon_rmap()</code> 里 PageAnonExclusive 和 GUP 有何关系？</p><h2 id="mlock" tabindex="-1">mlock() <a class="header-anchor" href="#mlock" aria-label="Permalink to “mlock()”">​</a></h2><ol><li>mlock 的作用：防止内存被交换出去</li><li>mlock() 的代码流程： <ol><li>会对指定的地址区间的 vma 进行 split，然后对这个 vma 设置 VM_LOCKED flag，</li><li>调用 gup API， <ol><li>但是 pages 参数是 NULL，因此不会额外增加引用计数，也就是说，不会 pin 内存。</li><li>在 gup 的 faultin_page() 流程中，会在 folio_add_lru_vma() 时 folio_set_mlocked() 设置 PG_mlocked 并放进 mlock_fbatch</li></ol></li><li>后续某一时刻在 lru_add() 时会 folio_evictable() 判断 PG_mlocked 得知是不可交换的，所以会 folio_set_unevictable(folio); 疑问：PG_mlocked 和 PG_unevictable 有何区别？我的理解是：PG_mlocked 一定是 PG_unevictable 的，但反之则不对。 因为对于所在 struct address_space 有 AS_UNEVICTABLE flag 的 folio 而言，该 folio 是 PG_unevictable 的。</li></ol></li></ol><p>注意，<code>populate_vma_page_range()</code> 并未传入 FOLL_GET 或 FOLL_PIN 参数。</p>`,61)])])}const d=i(n,[["render",p]]);export{g as __pageData,d as default};
