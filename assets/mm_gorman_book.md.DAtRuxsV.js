import{_ as a,c as t,o,aj as i}from"./chunks/framework.CcbH9oJh.js";const p=JSON.parse('{"title":"Understanding the Linux Virtual Memory Manager","description":"","frontmatter":{"head":[["meta",{"property":"og:title","content":"Understanding the Linux Virtual Memory Manager | Blog"}]]},"headers":[],"relativePath":"mm/gorman_book.md","filePath":"mm/gorman_book.md","lastUpdated":1761828946000}'),r={name:"mm/gorman_book.md"};function n(s,e,l,m,h,d){return o(),t("div",null,e[0]||(e[0]=[i('<h1 id="understanding-the-linux-virtual-memory-manager" tabindex="-1">Understanding the Linux Virtual Memory Manager <a class="header-anchor" href="#understanding-the-linux-virtual-memory-manager" aria-label="Permalink to “Understanding the Linux Virtual Memory Manager”">​</a></h1><ul><li><a href="https://pdos.csail.mit.edu/~sbw/links/gorman_book.pdf" target="_blank" rel="noreferrer">https://pdos.csail.mit.edu/~sbw/links/gorman_book.pdf</a></li><li><a href="https://www.kernel.org/doc/gorman/" target="_blank" rel="noreferrer">https://www.kernel.org/doc/gorman/</a></li></ul><p>这本书是按 2.6 版本写的，但仍不过时</p><h2 id="书籍目录" tabindex="-1">书籍目录 <a class="header-anchor" href="#书籍目录" aria-label="Permalink to “书籍目录”">​</a></h2><ol><li>introduction</li><li>describing physical memory</li><li>page table management</li><li>process address space</li><li>boot memory allocator</li><li>physical page allocation</li><li>noncontiguous memory allocation</li><li>slab allocator</li><li>high memory management</li><li>page frame reclamation</li><li>swap management</li><li>shared memory virtual filesystem</li><li>out of memory management</li></ol><h2 id="内存管理学习顺序" tabindex="-1">内存管理学习顺序 <a class="header-anchor" href="#内存管理学习顺序" aria-label="Permalink to “内存管理学习顺序”">​</a></h2><p>For when the code has to be approached afresh with a later VM, it is always best to start in an isolated region that has the minimum number of dependencies.</p><ol><li>In the case of the VM, the best starting point is the Out Of Memory (OOM) manager in mm/oom kill.c. It is a very gentle introduction to one corner of the VM where a process is selected to be killed in the event that memory in the system is low. Because this function touches so many diﬀerent aspects of the VM, it is covered last in this book.</li><li>The second subsystem to then examine is the noncontiguous memory allocator located in mm/vmalloc.c and discussed in Chapter 7 because it is reasonably contained within one ﬁle.</li><li>The third system should be the physical page allocator located in mm/page alloc.c and discussed in Chapter 6 for similar reasons.</li><li>The fourth system of interest is the creation of Virtual Memory Addresses (VMAs) and memory areas for processes discussed in Chapter 4.</li></ol><p>Between these systems, they have the bulk of the code patterns that are prevalent throughout the rest of the kernel code, which makes the deciphering of more complex systems such as the page replacement policy or the buﬀer Input/Output (I/O) much easier to comprehend.</p>',9)]))}const u=a(r,[["render",n]]);export{p as __pageData,u as default};
