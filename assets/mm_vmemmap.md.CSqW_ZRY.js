import{_ as i,c as a,o as n,aj as e}from"./chunks/framework.CcbH9oJh.js";const c=JSON.parse('{"title":"pfn_to_page() 的原理：mem_section 与 vmemmap","description":"","frontmatter":{"head":[["meta",{"property":"og:title","content":"pfn_to_page() 的原理：mem_section 与 vmemmap | Blog"}]]},"headers":[],"relativePath":"mm/vmemmap.md","filePath":"mm/vmemmap.md","lastUpdated":1761828946000}'),p={name:"mm/vmemmap.md"};function l(t,s,h,k,r,d){return n(),a("div",null,s[0]||(s[0]=[e(`<h1 id="pfn-to-page-的原理-mem-section-与-vmemmap" tabindex="-1">pfn_to_page() 的原理：mem_section 与 vmemmap <a class="header-anchor" href="#pfn-to-page-的原理-mem-section-与-vmemmap" aria-label="Permalink to “pfn_to_page() 的原理：mem_section 与 vmemmap”">​</a></h1><p>前文，我们讨论了 <a href="./page"><code>struct page</code></a>，那怎么根据 pfn 得到对应的 <code>struct page</code> 呢？</p><p>目前是默认开启了 <code>CONFIG_SPARSEMEM_VMEMMAP</code> 的，我这里也会提一下传统的没有用到 vmemmap 的 Sparse Memory Model。</p><h2 id="参考" tabindex="-1">参考 <a class="header-anchor" href="#参考" aria-label="Permalink to “参考”">​</a></h2><ul><li><a href="https://docs.kernel.org/arch/x86/x86_64/mm.html" target="_blank" rel="noreferrer">29.3. Memory Management — The Linux Kernel documentation</a> 虚拟内存布局</li><li><a href="https://docs.kernel.org/mm/memory-model.html" target="_blank" rel="noreferrer">Physical Memory Model — The Linux Kernel documentation</a> FLATMEM, SPARSEMEM 物理内存模型</li><li><a href="http://www.wowotech.net/memory_management/memory_model.html" target="_blank" rel="noreferrer">Linux 内存模型 - wowotech</a></li><li><a href="https://www.cnblogs.com/LoyenWang/p/11523678.html" target="_blank" rel="noreferrer">【原创】（四）Linux 内存模型之 Sparse Memory Model - LoyenWang - 博客园</a></li></ul><h2 id="vmemmap-区域" tabindex="-1">vmemmap 区域 <a class="header-anchor" href="#vmemmap-区域" aria-label="Permalink to “vmemmap 区域”">​</a></h2><p>本文主要讨论<a href="./layout">虚拟地址空间布局</a>中的 “virtual memory map (vmemmap_base)” 区域。 另外，“direct mapping of all physical memory” 这一段，是 64TB，说明 Linux 打算最多支持 64TB 的物理内存，这也可以在代码中得到验证：</p><div class="language-cpp line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// arch/x86/include/asm/sparsemem.h</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"># define</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> MAX_PHYSMEM_BITS</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">pgtable_l5_enabled</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">?</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 52</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> :</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 46</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> /* 2^46 就是 64TB */</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h2 id="概览" tabindex="-1">概览 <a class="header-anchor" href="#概览" aria-label="Permalink to “概览”">​</a></h2><p>pfn 即 page frame number，<code>page_to_pfn(pfn)</code> 可以得到 pfn 页帧对应的 <code>struct page *</code>。</p><div class="language-cpp line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/* memmap is virtually contiguous.  */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#define</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> __pfn_to_page</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">pfn</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)	(vmemmap </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (pfn))</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#define</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> __page_to_pfn</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">page</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)	(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">unsigned</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> long</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)((page) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> vmemmap)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#define</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> page_to_pfn</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> __page_to_pfn</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#define</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> pfn_to_page</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> __pfn_to_page</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><ol><li><p>vmemmap 是什么？</p><p>vmemmap 是一个虚拟地址。是 <code>[ffffea0000000000, ffffeaffffffffff]</code> 这一段 virtual memory map (简称 vmemmap) 区域的起始位置。</p></li><li><p>为什么 vmemmap + pfn 就能得到对应的 <code>struct page *</code> ？</p><p>vmemmap 区域内的一部分虚拟地址映射到了实际的物理页帧，这些物理页帧存放着 <code>struct page</code>。</p><p>因此 vmemmap 区域可以看作是一个大小 1TB 的 <code>struct page</code> 数组，可以容纳 <code>1TB / sizeof(struct page)</code> 个 <code>struct page</code>，可以描述 <code>1TB / 64B * 4KB = 64TB</code> 的物理内存。</p></li><li><p><code>struct page</code> 实际存储在哪？亦即：vmemmap 映射到哪块物理内存了？</p><p>可以说，初始化 mem_section 的过程，就是为 <code>struct page</code> 数组分配内存的过程。下文会讲。</p></li></ol><h2 id="mem-section-vmemmap" tabindex="-1">mem_section + vmemmap <a class="header-anchor" href="#mem-section-vmemmap" aria-label="Permalink to “mem_section + vmemmap”">​</a></h2><div class="language-cpp line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// mm/sparse.c</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#ifdef</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> CONFIG_SPARSEMEM_EXTREME</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/* 本文讨论这种情况 */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">struct</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> mem_section</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> **</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">mem_section;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#else</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">struct</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> mem_section</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> mem_section[NR_SECTION_ROOTS][SECTIONS_PER_ROOT]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  ____cacheline_internodealigned_in_smp;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#endif</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">EXPORT_SYMBOL</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(mem_section);</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p><code>mem_section</code> 是一个指针数组，包含 <code>NR_SECTION_ROOTS</code> 个指针。每个指针要么为 NULL（当物理内存稀疏时，可节省内存），要么指向一个 4KB 页面，每个页面里都是 <code>struct mem_section</code> 数组。</p><p>每个 <code>struct mem_section</code> 都代表了 128MB 内存，这也是 x86 内存热插拔的最小粒度。 是怎么代表 128MB 内存的呢？实际上，内核为每个 <code>struct mem_section</code> 分配了一个 2MB 的大页面，该页面由 <code>struct page</code> 数组组成，描述了 <code>2MB / 64B * 4KB = 128MB</code> 的内存，vmemmap 区域的某个虚拟地址会映射到该物理页面。</p><div class="language-cpp line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// include/linux/mmzone.h</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">struct</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> mem_section</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  /* 在不同的阶段，有不同的作用。</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   - 在早期启动阶段，</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">     (see sparse.c::memory_present())</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   - 完成启动后。可以通过 sparse_decode_mem_map() 转为一个 struct page *</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">     代表 128MB 的第一个页面</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">     (see sparse.c::sparse_init_one_section()) */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  unsigned</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> long</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> section_mem_map;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  struct</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> mem_section_usage</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">usage;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#ifdef</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> CONFIG_PAGE_EXTENSION</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  struct</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> page_ext</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">page_ext;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  unsigned</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> long</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> pad;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#endif</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><p>在初始化 mem_section、为 struct page 分配内存的过程中，会顺便建立好 vmemmap 区域的映射。</p><div class="language-cpp line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">sparse_init</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  /* 1. 先为 mem_section 分配好内存 */</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  memblocks_present</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    /* 分配 struct mem_section 指针数组 */</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    mem_section </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> memblock_alloc</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">sizeof</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(struct mem_section </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> NR_SECTION_ROOTS, align);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    /* 遍历实际存在的、不是空洞的内存区域 */</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    for_each_mem_pfn_range</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">      memory_present</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        /* 分配 struct mem_section 数组 */</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        sparse_index_init</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(section_nr, nid);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  /* 2. 初始化这些 mem_section */</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  for_each_present_section_nr</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    sparse_init_nid</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">      /* 分配 2MB 的物理页面，用于存放 struct page，并做好 vmemmap+pfn 到该物理内存的映射</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">         返回的 map 就是第一个 struct page 的虚拟地址 */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">      struct</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> page</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">map </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> __populate_section_memmap</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        /* vmemmap 区域内，struct page 的虚拟地址范围 */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        unsigned</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> long</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> start </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">unsigned</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> long</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">pfn_to_page</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(pfn);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        unsigned</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> long</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> end </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> start </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> nr_pages </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> sizeof</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(struct page);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        /* 分配 2MB 物理内存，并让 [start, end] 虚拟地址映射过去 */</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        vmemmap_populate</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(start, end, nid, altmap);</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">vmemmap_populate_hugepages</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">          /* 用的是 2MB 大页 */</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">          vmemmap_alloc_block_buf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(PMD_SIZE, node, altmap);</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">          vmemmap_set_pmd</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">      /* 完成对一个 mem_section 的初始化 */</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">      sparse_init_one_section</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">__nr_to_section</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(pnum), pnum, map, usage, SECTION_IS_EARLY);</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br></div></div><p><code>vmemmap_alloc_block_buf()</code> 会尝试从 <code>sparsemap_buf</code> 分配连续的 2MB 内存，<code>sparsemap_buf</code> 就是为了 vmemmap 而存在的，不细讲了，详见 <code>sparse_buffer_alloc()</code>。</p><h2 id="传统的-sparse-mem" tabindex="-1">传统的 sparse mem <a class="header-anchor" href="#传统的-sparse-mem" aria-label="Permalink to “传统的 sparse mem”">​</a></h2><p>在开启了 <code>CONFIG_SPARSEMEM</code> 但未开启 <code>CONFIG_SPARSEMEM_VMEMMAP</code> 时，也就是传统的 sparse mem 情况下，mem_section 有另一个作用。 对于传统的 sparse mem，<code>page_to_pfn</code> 不是借助 vmemmap 完成的，而是借助于 mem_section（效率更低）。造成这种差异的原因是，这两种情况下 <code>__populate_section_memmap</code> 函数的实现是不同的，传统的 sparse mem 并未建立起 vmemmap 的映射。</p><h2 id="mem-section-的其他作用" tabindex="-1">mem_section 的其他作用 <a class="header-anchor" href="#mem-section-的其他作用" aria-label="Permalink to “mem_section 的其他作用”">​</a></h2><p>见 <a href="./hotplug">memory hotplug</a></p><h2 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to “总结”">​</a></h2><p>mem_section 最初的作用是支持 <code>pfn_to_page()</code>，后面出现 <code>CONFIG_SPARSEMEM_VMEMMAP</code> 这一方案后，在初始化 mem_section、为 struct page 分配内存时，会顺便建立起 vmemmap 区域的映射，此后 <code>pfn_to_page()</code> 不需要 mem_section 的参与。（虽然也可以通过 <code>sparse_decode_mem_map()</code> 得到 struct page，但没 vmemmap 高效。）</p><h2 id="可以水个-patch-吗" tabindex="-1">可以水个 patch 吗 <a class="header-anchor" href="#可以水个-patch-吗" aria-label="Permalink to “可以水个 patch 吗”">​</a></h2><p><code>__section_mem_map_addr</code> 在未启用 <code>CONFIG_SPARSEMEM_VMEMMAP</code> 时用不到。</p><div class="language-cpp line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes github-light github-dark has-diff" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line diff add"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#if</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> defined</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">CONFIG_SPARSEMEM</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;&amp;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> !defined</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">CONFIG_SPARSEMEM_VMEMMAP</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">static</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> inline</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> struct</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> page</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">__section_mem_map_addr</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">struct</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> mem_section</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">section</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	unsigned</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> long</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> map </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> section-&gt;section_mem_map;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	map </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> SECTION_MAP_MASK;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">struct</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> page</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)map;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line diff add"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#endif</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div>`,29)]))}const g=i(p,[["render",l]]);export{c as __pageData,g as default};
