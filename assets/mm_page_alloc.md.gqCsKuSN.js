import{_ as a,c as l,o as i,al as s}from"./chunks/framework.CdzZEkix.js";const g=JSON.parse('{"title":"页面分配","description":"","frontmatter":{"head":[["meta",{"property":"og:title","content":"页面分配 | Blog"}]]},"headers":[],"relativePath":"mm/page_alloc.md","filePath":"mm/page_alloc.md","lastUpdated":1763912647000}'),r={name:"mm/page_alloc.md"};function o(t,e,n,p,_,c){return i(),l("div",null,[...e[0]||(e[0]=[s(`<h1 id="页面分配" tabindex="-1">页面分配 <a class="header-anchor" href="#页面分配" aria-label="Permalink to “页面分配”">​</a></h1><h2 id="关键知识点一览" tabindex="-1">关键知识点一览 <a class="header-anchor" href="#关键知识点一览" aria-label="Permalink to “关键知识点一览”">​</a></h2><ul><li>watermark</li><li>有 <code>__GFP_WRITE</code> 时，ac-&gt;spread_dirty_pages 为 true</li><li>cpuset 影响 <code>__GFP_HARDWALL</code> 和 ac-&gt;nodemask， 会限制当前 cpu 可以在哪些 node 分配内存</li><li>ALLOC_NOFRAGMENT 会使得从其他 migratetype 的 pageblock steal page 时，让 order 至少为 pageblock order，也就是说至少 steal 整个 pageblock，修改 pageblock 的 migratetype，而不会使得 pageblock 内同时有多种 migratetype 的 page，造成碎片化。</li><li>ac-&gt;highest_zoneidx 就是 gfp_zone(gfp_mask)，也就是可以最高可以从哪个 zonetype 的 zone 里分配，比如 GFP_NORMAL</li><li><a href="./sysctl/vm.zone_reclaim_mode">vm.zone_reclaim_mode</a></li></ul><div class="language-cpp line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">__alloc_frozen_pages_noprof</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  unsigned</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> alloc_flags </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ALLOC_WMARK_LOW;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  /* low mark */</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  get_page_from_freelist</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  __alloc_pages_slowpath</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h2 id="get-page-from-freelist" tabindex="-1">get_page_from_freelist() <a class="header-anchor" href="#get-page-from-freelist" aria-label="Permalink to “get_page_from_freelist()”">​</a></h2><ol><li>for_next_zone_zonelist_nodemask(zone, z, ac-&gt;highest_zoneidx, ac-&gt;nodemask) <ol><li>如果分配后不满足 high 水线，则记录 set_bit(ZONE_BELOW_HIGH, &amp;zone-&gt;flags);</li><li>如果分配后不满足当前要求的水线，则由 vm.zone_reclaim_mode 控制是否 node_reclaim() 只在当前 node 上回收内存，以及如何回收。详见 <a href="./sysctl/vm.zone_reclaim_mode">vm.zone_reclaim_mode</a></li><li>如果满足水线，则 rmqueue() 从 buddy system 中分配 <ol><li>如果 pcp_allowed_order() order 为 0-3 或 THP 的 order，则 rmqueue_pcplist() 从 percpu 链表中直接拿，用 percpu 的粒度小的锁。</li><li>否则，rmqueue_buddy() 从 zone 里的链表里拿，用 zone 粒度的锁。会以不同的参数调用 <code>__rmqueue_smallest()</code>： <ol><li>如果是 ALLOC_HIGHATOMIC high-order atomic 分配，则优先用 migratetype <code>MIGRATE_HIGHATOMIC</code></li><li>否则就 <code>__rmqueue()</code><ol><li>先用 ac-&gt;migratetype</li><li>如果失败，且如果允许 ALLOC_CMA，则用 <code>MIGRATE_CMA</code></li><li>还不行就 <code>__rmqueue_claim()</code><ol><li>如果 order&gt;= pageblock_order，就改变整个 pageblock 的 migratetype（不会造成碎片化），否则不改变</li><li>try_to_claim_block() 的作用详见 <a href="https://g.co/gemini/share/247c3aa86588" target="_blank" rel="noreferrer">https://g.co/gemini/share/247c3aa86588</a></li></ol></li><li>如果实在不行，而且没有 ALLOC_NOFRAGMENT，允许碎片化，就 <code>__rmqueue_steal()</code>，fallback 到其他 migratetype 进行窃取，不会改变 pageblock 的 migratetype，但这样使得该 pageblock 内的页面。在 <code>__del_page_from_free_list()</code> 里会打印 WARN。 <ol><li>如果我们要分配 Unmovable 的，但是从 movable pageblock 里分配了，那么要是将来内存规整时把这页面移动了咋办？详见 <a href="https://g.co/gemini/share/247c3aa86588" target="_blank" rel="noreferrer">https://g.co/gemini/share/247c3aa86588</a><ol><li>其实，如果我们不传入 <code>__GFP_MOVABLE</code> 标志，page alloc 时是不会给该 page 加上啥东西来防止页面将来被迁移的，如果我们要防止页面被迁移，那需要自己另作操作，比如 GUP。所以，页面能否迁移，和 pageblock 的 MIGRATE_MOVABLE 没任何关系。</li><li>那么，pageblock 的 MIGRATE_MOVABLE 的作用是什么呢？答：是为了让同一个 pageblock 内的页面的可移动性“尽可能地”相同，也就是<strong>在同一个 pageblock 内尽可能地申请具有相同可移动性的页面</strong>，也就是“根据可移动性分组”（这个“可移动性”取决于用户是否 gup，并不取决于 pageblock 的 migratetype），这样可以让内存规整时更为顺利。因此，可以说，<code>__rmqueue_steal()</code> 会污染 pageblock，可能会使得内存规整遍历到这个 MIGRATE_MOVABLE 的 pageblock 时遇到无法迁移的页面（如果被用户 gup 了），可能造成碎片化。</li></ol></li></ol></li></ol></li><li>如果分配失败，但是 ALLOC_OOM ALLOC_NON_BLOCK，那么就偷用 <code>MIGRATE_HIGHATOMIC</code> 来分配，因为相比于将来 high-order atomic 失败，此时在这里分配失败要更糟糕。</li></ol></li></ol></li></ol></li></ol><hr><p>最后都会 <code>__rmqueue_smallest()</code></p><ol><li>for (current_order = order; current_order &lt; NR_PAGE_ORDERS; ++current_order) <ol><li>得到链表头的 page = get_page_from_free_area(&amp;(zone-&gt;free_area[current_order]), migratetype);</li><li>page_del_and_expand() <ol><li>将该 page 从链表取下</li><li>expand() 如果该 page 的 order 比我们要的大，就分解出不需要的，放回 freelist</li></ol></li></ol></li></ol>`,9)])])}const h=a(r,[["render",o]]);export{g as __pageData,h as default};
