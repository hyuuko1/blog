import{_ as l,c as a,o as i,aj as r}from"./chunks/framework.CcbH9oJh.js";const g=JSON.parse('{"title":"内存回收 - 基础","description":"","frontmatter":{"head":[["meta",{"property":"og:title","content":"内存回收 - 基础 | Blog"}]]},"headers":[],"relativePath":"mm/reclaim/basic.md","filePath":"mm/reclaim/basic.md","lastUpdated":1761828946000}'),t={name:"mm/reclaim/basic.md"};function n(o,e,s,c,h,m){return i(),a("div",null,e[0]||(e[0]=[r('<h1 id="内存回收-基础" tabindex="-1">内存回收 - 基础 <a class="header-anchor" href="#内存回收-基础" aria-label="Permalink to “内存回收 - 基础”">​</a></h1><p><a href="./../reclaim">内存回收旧版笔记</a></p><p>按顺序来：</p><ol><li><a href="./../page_alloc">物理内存分配</a>，了解几种内存回收方式的触发条件和路径</li><li>学习几种内存回收方式的区别，node_reclaim、direct_reclaim、kswapd reclaim</li><li>学习内存回收机制，先看关键流程，再深入函数细节。 <ol><li>scan_control</li><li><a href="./workingset">workingset</a></li><li>active/inactive 之间的平衡、file/anon 之间的平衡</li><li>shrink_lruvec() <ol><li>shrink_active_list</li><li>shrink_inactive_list</li></ol></li><li>shrink_slab</li><li>reclaim throttling</li></ol></li><li><a href="./mglru">MGLRU</a></li><li>深入更底层 <ol><li>writeback</li><li>swap_cache, swap in/out</li></ol></li><li>zswap</li><li>swap tableF</li></ol><p>做一些总结：folio 在各个 active/inactive lru 链表之间的流转 <a href="./lru">lru</a>，folio 的生命周期。</p><ul><li>从 buddy 到 inactive</li><li>从 inactive promoted 到 active</li><li>从 active demoted 到 inactive</li><li>从 inactive evicted</li><li>从 inactive rotate 到 inactive head</li></ul><p>挖掘演进历史 总结每个函数的作用。vmscan.c swap.c workingset.c</p><h2 id="内存回收的触发条件、回收方式" tabindex="-1">内存回收的触发条件、回收方式 <a class="header-anchor" href="#内存回收的触发条件、回收方式" aria-label="Permalink to “内存回收的触发条件、回收方式”">​</a></h2><ul><li>内存回收的触发路径。 <ul><li>get_page_from_freelist() 时的 node_reclaim()，见 <a href="./../page_alloc">page_alloc 快速路径</a>。</li><li>kswapd 线程的间接回收。</li><li>慢速路径的直接回收。</li></ul></li></ul><p>关注于 <code>struct scan_control</code></p><h2 id="lru-演进历程" tabindex="-1">LRU 演进历程 <a class="header-anchor" href="#lru-演进历程" aria-label="Permalink to “LRU 演进历程”">​</a></h2><ul><li>2014-02-04 <a href="https://lore.kernel.org/linux-mm/1391475222-1169-1-git-send-email-hannes@cmpxchg.org/" target="_blank" rel="noreferrer">[patch 00/10] mm: thrash detection-based file cache sizing v9</a><ul><li>2012-05-02 <a href="https://lwn.net/Articles/495543/" target="_blank" rel="noreferrer">Better active/inactive list balancing [LWN.net]</a></li><li><a href="https://aistudio.google.com/prompts/1-YbmIW_NyHmLzDG_OqFLZl9VVOv72oxK" target="_blank" rel="noreferrer">https://aistudio.google.com/prompts/1-YbmIW_NyHmLzDG_OqFLZl9VVOv72oxK</a></li></ul></li><li>2020-05-20 <a href="https://lore.kernel.org/linux-mm/20200520232525.798933-1-hannes@cmpxchg.org/" target="_blank" rel="noreferrer">[PATCH 00/14] mm: balance LRU lists based on relative thrashing v2 - Johannes Weiner</a><ul><li><a href="https://aistudio.google.com/app/prompts/1b663zgF2iTeI-yuVMM0zYnaikIwa4LW6" target="_blank" rel="noreferrer">https://aistudio.google.com/app/prompts/1b663zgF2iTeI-yuVMM0zYnaikIwa4LW6</a></li></ul></li><li>2020-06-16 <a href="https://lore.kernel.org/linux-mm/1592288204-27734-1-git-send-email-iamjoonsoo.kim@lge.com/" target="_blank" rel="noreferrer">[PATCH for v5.8 0/3] fix for “mm: balance LRU lists based on relative thrashing” patchset - js1304</a></li><li>2020-07-23 <a href="https://lore.kernel.org/linux-mm/1595490560-15117-1-git-send-email-iamjoonsoo.kim@lge.com/" target="_blank" rel="noreferrer">[PATCH v7 0/6] workingset protection/detection on the anonymous LRU list - js1304</a> 对匿名页的 workingset 保护 <ul><li>2020-03-10 <a href="https://lwn.net/Articles/815342/" target="_blank" rel="noreferrer">Working-set protection for anonymous pages [LWN.net]</a></li><li>原先，匿名页在 refault 时，会无条件地进入 active list head，</li></ul></li><li>2022-09-18 <a href="https://lore.kernel.org/linux-mm/20220918080010.2920238-1-yuzhao@google.com/" target="_blank" rel="noreferrer">[PATCH mm-unstable v15 00/14] Multi-Gen LRU Framework - Yu Zhao</a> 引入 MGLRU <ul><li>2021-04-02 <a href="https://lwn.net/Articles/851184/" target="_blank" rel="noreferrer">The multi-generational LRU [LWN.net]</a></li><li>2021-05-24 <a href="https://lwn.net/Articles/856931/" target="_blank" rel="noreferrer">Multi-generational LRU: the next generation [LWN.net]</a></li><li>2022-05-12 <a href="https://lwn.net/Articles/894859/" target="_blank" rel="noreferrer">Merging the multi-generational LRU [LWN.net]</a></li></ul></li><li>2023-05-18 <a href="https://lwn.net/Articles/931812/" target="_blank" rel="noreferrer">Page aging with hardware counters [LWN.net]</a></li></ul><p>其他比较小的改动</p><ul><li>2009-06-08 <a href="https://lore.kernel.org/linux-mm/20090608091044.880249722@intel.com/" target="_blank" rel="noreferrer">[PATCH 0/3] make mapped executable pages the first class citizen (with test cases) - Wu Fengguang</a><ul><li>2009-05-19 <a href="https://lwn.net/Articles/333742/" target="_blank" rel="noreferrer">Being nicer to executable pages [LWN.net]</a></li><li>可执行文件页更不容易 deactivate</li></ul></li><li>2019-11-07 <a href="https://lore.kernel.org/linux-mm/20191107205334.158354-1-hannes@cmpxchg.org/" target="_blank" rel="noreferrer">[PATCH 0/3] mm: fix page aging across multiple cgroups</a></li><li>2021-01-17 Linus Torvalds feb889fb40fa mm: don&#39;t put pinned pages into the swap cache <ul><li>不把 pinned pages 放进 swap cache</li></ul></li></ul>',14)]))}const u=l(t,[["render",n]]);export{g as __pageData,u as default};
