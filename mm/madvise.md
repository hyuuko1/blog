# madvise

- [宋宝华：论 Linux 的页迁移（Page Migration）完整版](https://cloud.tencent.com/developer/article/1681326)

## MADV_FREE / MADV_DONTNEED / munmap()

这三者都与释放内存有关，但它们在目的、行为和对性能的影响上有着本质的区别。

### 核心区别速览表

先用一个表格来总结它们的核心区别：

| 特性         | `munmap()`                                                   | `madvise(..., MADV_DONTNEED)`                                                                              | `madvise(..., MADV_FREE)`                                                                                                                              |
| :----------- | :----------------------------------------------------------- | :--------------------------------------------------------------------------------------------------------- | :----------------------------------------------------------------------------------------------------------------------------------------------------- |
| **核心作用** | 解除内存映射                                                 | 建议内核立即丢弃页面                                                                                       | 建议内核将页面标记为可回收                                                                                                                             |
| **地址空间** | **无效** (VMA 被移除)                                        | **有效** (VMA 保留)                                                                                        | **有效** (VMA 保留)                                                                                                                                    |
| **后续访问** | 段错误 (`SIGSEGV`)                                           | **数据清零** (匿名映射) 或从文件重新读入                                                                   | **可能保留数据** (若内核未回收) 或数据清零                                                                                                             |
| **物理内存** | 立即归还给系统                                               | 立即归还给系统                                                                                             | **延迟归还**，仅当系统需要时才回收                                                                                                                     |
| **性能开销** | 较高，涉及 VMA 操作                                          | 中等，立即丢弃，再次访问有缺页+清零开销                                                                    | **较低**，再次写入若未被回收，则开销极小                                                                                                               |
| **内核版本** | 所有版本                                                     | 所有版本                                                                                                   | Linux Kernel **4.5+**                                                                                                                                  |
| **通俗比喻** | **退租**：你把房子还给房东，钥匙也交了，再进去就是非法闯入。 | **大扫除**：你告诉管家“这个房间我暂时不用，把里面的东西全扔了”。管家立即清空房间。你再进去时，房间是空的。 | **贴封条**：你告诉管家“这个房间我可能不用了，你先贴个封条，如果有人急需，你就清空给别人用”。在你回去之前，如果没人用，你可以撕掉封条继续用里面的东西。 |

---

### 详细解析与实现原理

#### 1. `munmap(void *addr, size_t length)`

`munmap()` 是一个彻底的、决定性的操作。它用于解除一个已经存在的内存映射。

- **实现原理**:

  1.  **VMA (Virtual Memory Area) 移除**: 当进程调用 `munmap()` 时，内核会找到 `addr` 和 `length` 对应的 VMA 结构体 (`struct vm_area_struct`)。它会从进程的内存描述符 (`mm_struct`) 的红黑树和链表中移除这个 VMA（或者根据地址范围分裂、合并 VMA）。这是一个相对较重的操作，因为它改变了进程的地址空间布局。
  2.  **页表解除**: 内核会遍历该地址范围对应的页表项 (PTEs)，将它们全部标记为无效，并刷新 TLB (Translation Lookaside Buffer)。
  3.  **物理页处理**: 对于映射的物理页面，内核会减少它们的引用计数。
      - 对于匿名页面（如 `mmap(MAP_ANONYMOUS)`），如果引用计数降为零，这些物理页面会被立即释放回伙伴系统 (Buddy System)，可供系统其他部分使用。
      - 对于文件映射页面，引用计数减少。如果页面是脏的（被修改过），会根据映射类型（`MAP_SHARED` 或 `MAP_PRIVATE`）决定是否写回磁盘。之后页面可能会保留在页缓存 (Page Cache) 中。

- **使用场景**:

  - **确定性释放**: 当你完全确定一块内存（例如一个大的缓冲区、一个关闭的动态链接库、一个处理完毕的文件映射）未来再也不会被访问时，应该使用 `munmap()`。
  - **内存管理器**: `glibc` 的 `malloc` 在通过 `mmap` 分配了非常大的内存块后，当用户 `free()` 这块内存时，可能会调用 `munmap()` 将其完全归还给操作系统，以避免内存空洞和浪费。

- **实践建议**:
  - 这是最干净、最彻底的内存释放方式。
  - 调用 `munmap()` 后，任何对该地址范围的访问都会立即导致段错误 (`SIGSEGV`)，这有助于调试悬挂指针问题。
  - 由于它会修改 VMA 结构，对于频繁、小块的释放，开销相对较大。

#### 2. `madvise(void *addr, size_t length, MADV_DONTNEED)`

`madvise()` 是给内核的一个“建议”，`MADV_DONTNEED` 是一个比较强硬的建议。它告诉内核：“我暂时不需要这块内存里的数据了，你可以立即回收物理页面。”

- **实现原理**:

  1.  **VMA 不变**: `MADV_DONTNEED` **不会** 移除 VMA。进程的地址空间布局保持不变，这块内存地址对于进程来说依然是合法的。
  2.  **页表解除与物理页丢弃**: 内核遍历该范围的 PTEs。对于每一个 PTE 指向的物理页面：
      - 如果是干净的 (clean) 匿名页或文件页，内核直接断开 PTE 与物理页的连接，并将物理页释放。
      - 如果是脏的 (dirty) 匿名页，内核会尝试将其写入交换空间 (Swap)，然后释放物理页。
      - 如果是脏的私有文件映射页 (`MAP_PRIVATE`)，内容直接被丢弃。
      - 如果是脏的共享文件映射页 (`MAP_SHARED`)，内容会被写回文件。
  3.  **后续访问**: 当进程再次访问这个范围内的地址时，由于 VMA 存在但 PTE 无效，会触发一个缺页中断 (Page Fault)。内核的缺页处理程序会为这个地址分配一个新的、**内容为全零的**物理页面（对于匿名映射），或者从后备文件重新读取数据（对于文件映射）。

- **使用场景**:

  - **内存裁剪 (Trimming)**: 适用于那些有内存使用峰值的长时间运行服务。当服务处理完一个大请求，占用了大量内存作为临时缓冲区后，可以在不 `munmap` 整个内存池的情况下，使用 `MADV_DONTNEED` 快速降低进程的 RSS (Resident Set Size)，将物理内存还给系统。
  - **对象池/内存池**: 当内存池中的大量对象被释放，但内存池本身结构需要保留以备后续分配时，可以用 `MADV_DONTNEED` 清理那些空闲的内存区域。

- **实践建议**:
  - 这是一个降低 RSS 的有效手段，效果立竿见影。
  - 它的主要缺点是**数据丢失**（对于匿名映射）。如果之后很快又需要使用这块内存，进程不仅要承受缺页中断的开销，还要承受内核清零页面的开销。这种“先释放、再分配清零”的模式可能导致性能抖动。

#### 3. `madvise(void *addr, size_t length, MADV_FREE)`

`MADV_FREE` 是在 Linux 4.5 内核中引入的，可以看作是 `MADV_DONTNEED` 的一个更智能、更惰性 (lazy) 的版本。它告诉内核：“我不再需要这块内存里的数据了，你可以回收它，但不必立即行动。”

- **实现原理**:

  1.  **VMA 不变**: 和 `MADV_DONTNEED` 一样，VMA 保持不变。
  2.  **惰性回收**: 内核收到 `MADV_FREE` 建议后，并**不会立即丢弃**物理页面。它只是简单地将这些页面的 PTE 标记为无效，并将这些物理页面放入一个特殊的非活跃列表 (`inactive list`) 中。这些页面现在是回收的候选者。
  3.  **后续访问**:
      - **情况 A (内核未回收)**: 如果在内核因内存压力而真正回收这些页面**之前**，进程又**写入**了这块内存，会触发一个缺页中断。但内核会发现这个物理页面其实还在（只是被标记了），于是它可以简单地恢复 PTE 的有效性，重新将页面映射回来。这个过程非常快，因为**数据没有丢失**，也不需要分配和清零新页面。
      - **情况 B (内核已回收)**: 如果系统存在内存压力，内核的页面回收守护进程 (`kswapd`) 会扫描非活跃列表，并最终回收这些被 `MADV_FREE` 标记的页面。此后，如果进程再访问这块内存，其行为就和 `MADV_DONTNEED` 一样了：触发缺页中断，分配一个清零的新页面。

- **使用场景**:

  - **高性能对象缓存/内存池**: 这是 `MADV_FREE` 的理想场景。当一个对象被释放回池中时，应用可以对该对象的内存调用 `MADV_FREE`。
    - 如果这个内存槽位很快被新对象复用，那么性能开销极小（只有一次软缺页的成本）。
    - 如果这个内存槽位长时间空闲，并且系统需要内存，它会被透明地回收，帮助降低整体内存占用。
  - 它完美地平衡了“快速复用”和“在需要时归还内存给系统”这两个需求。

- **实践建议**:
  - 在内核版本 >= 4.5 的系统上，对于那些可能被快速重用的内存区域（如各种 cache、pool、arena），**`MADV_FREE` 是比 `MADV_DONTNEED` 更好的选择**。
  - 它避免了 `MADV_DONTNEED` 在“释放-再分配”循环中的性能惩罚，是一种更高效的内存管理策略。

---

### 总结与决策指南

根据您的需求，可以遵循以下逻辑来选择：

1.  **这块内存地址之后还会使用吗？**

    - **否，永远不会再用了**: 使用 `munmap()`。这是最彻底、最正确的选择。
    - **是，之后还会用**: 进入下一步。

2.  **内核版本是否高于等于 4.5？**

    - **是 (现代系统)**: 进入下一步。
    - **否 (老旧系统)**: 你只能使用 `MADV_DONTNEED`。你需要仔细评估再次使用时的清零开销。

3.  **这块内存是用于缓存/对象池，且复用率较高吗？**
    - **是**: 优先使用 `MADV_FREE`。它为高复用率场景提供了最佳性能，同时在低复用率和系统内存紧张时又能表现出良好的内存回收行为。
    - **否，只是想立即降低内存占用，且不关心后续访问的性能**: 可以考虑使用 `MADV_DONTNEED`。它的行为更具确定性，调用后 RSS 立即下降。但在现代内核上，除非有特殊理由，否则 `MADV_FREE` 通常是更优的建议。

总而言之，`munmap` 是**销毁映射**，`madvise` 是在**保留映射**的前提下对物理内存的**管理建议**。而在 `madvise` 的两个选项中，`MADV_DONTNEED` 是一个急躁的、立即执行的“丢弃”命令，而 `MADV_FREE` 则是一个温和的、可撤销的“标记待回收”建议，为现代应用程序提供了更精细、更高效的内存管理能力。
