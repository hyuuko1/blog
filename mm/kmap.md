# kmap

## 省流版

- [High Memory Handling — The Linux Kernel documentation](https://docs.kernel.org/mm/highmem.html)

kmap 用于 32bit。现在写代码时，如果场景合适（短暂的单个页面映射），为了兼容 32bit，也应使用 kmap_local_folio() 而非 page_to_virt()。

kmap 能做的，vmap 都能做。
kmap 的页表是提前分配好了的，每次只能映射单个页面（同时意味着：很容易分配虚拟地址），所以相对于 vmap 而言，优点只有一个，那就是快！

- `kmap()` 可能睡眠，即使是在 64bit 系统
- `kmap_local_page()` 可以在任何上下文调用，包括中断上下文。建议用这个。

## Linux 内核中 vmap 与 kmap 的并存之谜：为何有了 vmap 还需要 kmap？

在 Linux 内核的内存管理中，`vmap` 和 `kmap` 都是用于将物理页面映射到内核虚拟地址空间的函数，但它们的设计目标和适用场景截然不同。尽管 `vmap` 提供了创建较大、虚拟连续映射的能力，`kmap` 及其衍生函数在处理单个页面的临时映射方面仍然不可或缺。简而言之，**`vmap` 解决了“大块”和“长期”的映射需求，而 `kmap` 则专注于“单个”和“短期”的高效访问**。

### vmap 和 kmap 的核心区别

| 特性               | vmap                                                 | kmap                                           |
| :----------------- | :--------------------------------------------------- | :--------------------------------------------- |
| **映射单位**       | 多个物理页面                                         | 单个物理页面                                   |
| **虚拟地址连续性** | 是                                                   | 否（只映射一页）                               |
| **物理地址连续性** | 否                                                   | 不适用（只映射一页）                           |
| **映射时长**       | 长期                                                 | 短期                                           |
| **性能开销**       | 较高，涉及页表构建                                   | 相对较低，但有全局同步开销                     |
| **主要用途**       | 将非连续的物理页面映射成一个虚拟上连续的大块内存区域 | 临时访问单个物理页面，尤其是“高端内存”中的页面 |

### 为何 vmap 不能完全替代 kmap？

`vmap` 的主要职责是将一组物理上不一定连续的页面映射到一个虚拟地址空间上连续的区域。这对于需要大块连续虚拟内存的场景（例如，加载内核模块或为某些驱动程序分配缓冲区）非常有用。然而，`vmap` 的实现相对复杂，需要建立新的页表，开销较大，不适合频繁地对单个页面进行短暂的映射和解除映射操作。

`kmap` 的存在正是为了弥补这一不足。它的核心价值在于提供一种轻量级的方式来临时获取一个物理页面的虚拟地址。这在以下场景中至关重要：

- **访问高端内存（High Memory）**：在 32 位系统中，内核的直接映射空间有限（通常为 896MB），无法将所有的物理内存都永久映射到内核地址空间。超出这部分直接映射区域的物理内存被称为“高端内存”。当内核需要访问高端内存中的某个页面时，就必须通过 `kmap` 临时地将该页面映射到内核地址空间的一小块专用区域中。

- **效率和短期使用**：`kmap` 专为短暂的页面访问设计。驱动程序或其他内核代码可能只需要在很短的时间内读取或修改某个页面的内容。在这种情况下，使用重量级的 `vmap` 会带来不必要的性能损耗。`kmap` 提供了一种更快捷的机制来完成这个任务。

### kmap 的演进：从 kmap 到 kmap_local_page

值得注意的是，原始的 `kmap` 函数存在一些性能瓶颈，因为它需要在所有 CPU 之间进行昂贵的 TLB（转译后备缓冲区）刷新，以同步映射的更改。 为了解决这些问题，内核引入了新的替代方案：

- **`kmap_atomic()`**：这是一个更快的版本，它创建的映射仅在当前 CPU 上有效，并且在使用期间会禁用抢占。这避免了跨 CPU 同步的开销，适用于非常短暂且在原子上下文中进行的页面访问。

- **`kmap_local_page()`**：作为 `kmap` 的现代替代品，它创建的映射是线程本地和 CPU 本地的。这意味着映射只能在获取它的线程中访问，并且该线程在此期间会被绑定到当前 CPU 上。这种方式比 `kmap` 更高效，并且在使用上限制更少，例如它不会禁用抢占。

在现代 Linux 内核中，**官方已经不鼓励在新的代码中使用 `kmap`**，并推荐使用 `kmap_local_page()` 来代替。

### 结论

尽管 64 位系统的普及极大地扩展了内核的虚拟地址空间，使得大部分物理内存都可以被直接映射，从而降低了对 `kmap` 的依赖性， 但 `kmap` 及其后续演进版本所代表的设计思想——即为单个页面提供高效、临时的内核映射——仍然具有重要意义。

总而言之，`vmap` 和 `kmap` 在 Linux 内核中并存，是因为它们服务于两个不同的目标：

- **`vmap`** 用于创建**长期**的、**虚拟地址连续**的内存区域，可以由**多个**物理页面组成。
- **`kmap`**（及其现代替代品）用于**短期**、**高效地**访问**单个**物理页面，解决了历史遗留的高端内存访问问题，并为临时页面操作提供了轻量级的解决方案。

## 推荐使用 kmap()还是 page_to_virt()

好的，这是一个非常贴近内核实际开发的优秀问题。

在当前时间点，如果需要考虑与 32 位系统的兼容性，给定一个 `struct folio` 来获取其内核虚拟地址，**我强烈推荐使用 `kmap()` 的现代替代品，而不是 `page_to_virt()`**。

更具体地说，最佳实践是使用 **`kmap_local_page()`** 或其 folio 版本的 **`kmap_local_folio()`**。

下面我将详细解释为什么，并对 `kmap()` 和 `page_to_virt()` (及其 folio 对应的 `folio_address()`) 进行深入比较。

### 核心原因：高端内存 (High Memory)

这个问题的关键在于 32 位系统架构下的“高端内存”概念。

1.  **32 位系统的地址空间限制**：一个 32 位的 CPU 只有 4GB 的虚拟地址空间。在 Linux 中，这通常被划分为 3GB 的用户空间和 1GB 的内核空间。
2.  **内核直接映射区**：在这 1GB 的内核空间中，内核会拿出一大块（通常是 896MB）来创建一个**直接的、线性的物理内存映射**。也就是说，这块区域里的每一个虚拟地址都通过一个简单的偏移量对应一个物理地址。这部分物理内存被称为**低端内存 (Low Memory)** 或 ZONE_NORMAL。
3.  **高端内存的诞生**：如果一台 32 位机器的物理内存超过了 896MB（例如，有 2GB 内存），那么超出 896MB 的那部分物理内存就无法被永久地、直接地映射到内核地址空间。这部分内存就被称为**高端内存 (High Memory)** 或 ZONE_HIGHMEM。
4.  **访问高端内存**：内核如果想访问高端内存中的某个页面，就必须**临时地**将该物理页面“借用”一小块内核虚拟地址空间来映射它。完成访问后，必须解除这个映射，以便其他代码可以“借用”这个虚拟地址。

### `kmap()` vs. `page_to_virt()` 的对决

| 特性         | `page_to_virt()` (及其等价的 `folio_address()`)                                                      | `kmap()` (及其现代替代品)                                                                   |
| :----------- | :--------------------------------------------------------------------------------------------------- | :------------------------------------------------------------------------------------------ |
| **适用内存** | **只能用于低端内存 (Low Memory)**                                                                    | **通用**，对低端和高端内存都有效                                                            |
| **实现机制** | 一个快速的地址计算（宏定义），几乎没有开销                                                           | 创建一个临时的内核虚拟地址映射，涉及页表操作                                                |
| **可靠性**   | **不可靠**。如果 folio 来自高端内存，它会返回一个无效的、无意义的地址，导致内核崩溃 (Kernel Panic)。 | **可靠且安全**。它保证能为任何给定的 folio/page 提供一个可用的内核虚拟地址。                |
| **性能开销** | 极低                                                                                                 | 相对较高，但现代的 `kmap_local_*` 已极大优化                                                |
| **使用方式** | `void *vaddr = folio_address(folio);`                                                                | `void *vaddr = kmap(folio_page(folio, 0));` <br> `...` <br> `kunmap(folio_page(folio, 0));` |

### 为什么推荐 `kmap()` 的现代替代品

**`page_to_virt()` / `folio_address()` 的致命缺陷：**

它的工作前提是 folio 必须位于低端内存。在编写驱动或内核模块时，你通常无法保证你拿到的 `struct folio` 一定来自低端内存。它可能来自用户空间、块设备、或者其他任何地方，完全有可能是高端内存。在这样的 `folio` 上调用 `folio_address()` 会导致灾难性的后果。

**`kmap()` 的安全保障：**

`kmap()` 及其家族的设计初衷就是为了解决这个问题。它的内部逻辑是：

1.  检查页面是否是高端内存。
2.  如果是低端内存，它会直接返回 `page_address()` 的结果，快速高效。
3.  如果是高端内存，它会从一个专用的虚拟地址池中取出一个地址，建立物理页面到该虚拟地址的映射，然后返回这个地址。

因此，**`kmap()` 是一个可以处理所有情况的、健壮的解决方案。**

### 现代内核的最佳实践：`kmap_local_page()` / `kmap_local_folio()`

原始的 `kmap()` 因为使用了全局锁，在多核系统上存在性能瓶颈，因此已经被标记为不推荐使用。现代内核推荐使用它的本地化版本：

- `kmap_local_page()`
- `kmap_local_folio()`

这些函数创建的映射是线程本地和 CPU 本地的，避免了全局同步开销，性能更好，并且在使用期间不会禁用抢占（与更早的 `kmap_atomic` 不同）。

#### 使用示例：

```c
// 给定一个 struct folio *my_folio;

// 1. 获取一个可用的内核虚拟地址
void *vaddr = kmap_local_folio(my_folio, 0); // 第二个参数是 folio 内的页面偏移

// 2. 现在可以安全地通过 vaddr 访问这个 folio 的内容了
//    例如，将内容清零
memset(vaddr, 0, PAGE_SIZE);

// 3. 操作完成后，必须解除映射
kunmap_local(vaddr);
```

### 结论

在需要考虑 32 位兼容性的前提下，当你要将一个 `struct folio` 转换为内核虚拟地址时：

1.  **绝对不要**直接使用 `page_to_virt()` 或 `folio_address()`，除非你通过其他方式（例如检查 `PageHighMem()`）100% 确定该 folio 位于低端内存。否则，你的代码存在严重且难以调试的 Bug。
2.  **不要使用**旧的 `kmap()`，因为它已被更高效的本地化版本取代。
3.  **正确的选择是使用 `kmap_local_folio()`**。这是当前最安全、最高效、最符合现代内核编码规范的做法，它能优雅地处理所有情况，让你的代码在 32 位和 64 位系统上都能正确运行。
