<!DOCTYPE html>
<html lang="zh-Hans" dir="ltr">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>任务调度 | Blog</title>
    <meta name="description" content="Linux kernel 内核代码分析，原理详解">
    <meta name="generator" content="VitePress v2.0.0-alpha.13">
    <link rel="preload stylesheet" href="/blog/assets/style.Cg8D8EfQ.css" as="style">
    <link rel="preload stylesheet" href="/blog/vp-icons.css" as="style">
    <script type="module" src="/blog/assets/chunks/metadata.e2231c71.js"></script>
    <script type="module" src="/blog/assets/app.DgFSTuZM.js"></script>
    <link rel="preload" href="/blog/assets/inter-roman-latin.Di8DUHzh.woff2" as="font" type="font/woff2" crossorigin="">
    <link rel="modulepreload" href="/blog/assets/chunks/theme.3WDp7bvS.js">
    <link rel="modulepreload" href="/blog/assets/chunks/framework.CdzZEkix.js">
    <link rel="modulepreload" href="/blog/assets/sched_index.md.BtX4qtZW.lean.js">
    <link rel="icon" type="image/svg+xml" href="/blog/linux.svg">
    <link rel="icon" type="image/png" href="/blog/linux-32x32.png">
    <meta name="theme-color" content="#5f67ee">
    <meta property="og:type" content="website">
    <meta property="og:locale" content="zh_CN">
    <meta property="og:title" content="任务调度 | Blog">
    <meta property="og:site_name" content="Linux kernel 内核代码分析，原理详解">
    <meta property="og:url" content="https://hyuuko.vercel.app">
    <meta name="google-site-verification" content="OMML6xlbLb2Asitovo85pbOZGTvYoWaYWYW3ps7083s">
    <meta name="msvalidate.01" content="E3B108A75866D6C18B16BE35E14DE820">
    <script id="check-dark-mode">(()=>{const e=localStorage.getItem("vitepress-theme-appearance")||"auto",a=window.matchMedia("(prefers-color-scheme: dark)").matches;(!e||e==="auto"?a:e==="dark")&&document.documentElement.classList.add("dark")})();</script>
    <script id="check-mac-os">document.documentElement.classList.toggle("mac",/Mac|iPhone|iPod|iPad/i.test(navigator.platform));</script>
  </head>
  <body>
    <div id="app"><div class="Layout" data-v-304c8b69><!--[--><!--]--><!--[--><span tabindex="-1" data-v-10d4d845></span><a href="#VPContent" class="VPSkipLink visually-hidden" data-v-10d4d845>Skip to content</a><!--]--><!----><header class="VPNav" data-v-304c8b69 data-v-d5bf7c8e><div class="VPNavBar" data-v-d5bf7c8e data-v-8eab0e6d><div class="wrapper" data-v-8eab0e6d><div class="container" data-v-8eab0e6d><div class="title" data-v-8eab0e6d><div class="VPNavBarTitle has-sidebar" data-v-8eab0e6d data-v-d4488dd0><a class="title" href="/blog/" data-v-d4488dd0><!--[--><!--]--><!--[--><img class="VPImage logo" src="/blog/linux.svg" width="20" height="20" alt data-v-ab19afbb><!--]--><span data-v-d4488dd0>Blog</span><!--[--><!--]--></a></div></div><div class="content" data-v-8eab0e6d><div class="content-body" data-v-8eab0e6d><!--[--><!--]--><div class="VPNavBarSearch search" data-v-8eab0e6d><!--[--><!----><div id="local-search"><button type="button" aria-label="搜索文档" aria-keyshortcuts="/ control+k meta+k" class="DocSearch DocSearch-Button"><span class="DocSearch-Button-Container"><span class="vpi-search DocSearch-Search-Icon"></span><span class="DocSearch-Button-Placeholder">搜索文档</span></span><span class="DocSearch-Button-Keys"><kbd class="DocSearch-Button-Key"></kbd><kbd class="DocSearch-Button-Key"></kbd></span></button></div><!--]--></div><nav aria-labelledby="main-nav-aria-label" class="VPNavBarMenu menu" data-v-8eab0e6d data-v-020be4db><span id="main-nav-aria-label" class="visually-hidden" data-v-020be4db> Main Navigation </span><!--[--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/blog/mm/index" tabindex="0" data-v-020be4db data-v-81dba28a><!--[--><span data-v-81dba28a>内存管理</span><!--]--></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/blog/net/index" tabindex="0" data-v-020be4db data-v-81dba28a><!--[--><span data-v-81dba28a>网络</span><!--]--></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/blog/storage/index" tabindex="0" data-v-020be4db data-v-81dba28a><!--[--><span data-v-81dba28a>存储</span><!--]--></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/blog/process/index" tabindex="0" data-v-020be4db data-v-81dba28a><!--[--><span data-v-81dba28a>进程</span><!--]--></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink active" href="/blog/sched/index" tabindex="0" data-v-020be4db data-v-81dba28a><!--[--><span data-v-81dba28a>调度</span><!--]--></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/blog/irq/index" tabindex="0" data-v-020be4db data-v-81dba28a><!--[--><span data-v-81dba28a>中断</span><!--]--></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/blog/arch/index" tabindex="0" data-v-020be4db data-v-81dba28a><!--[--><span data-v-81dba28a>体系结构</span><!--]--></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/blog/debug/index" tabindex="0" data-v-020be4db data-v-81dba28a><!--[--><span data-v-81dba28a>调试</span><!--]--></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/blog/virtualization/index" tabindex="0" data-v-020be4db data-v-81dba28a><!--[--><span data-v-81dba28a>虚拟化</span><!--]--></a><!--]--><!--[--><div class="VPFlyout VPNavBarMenuGroup" data-v-020be4db data-v-d8fae6e2><button type="button" class="button" aria-haspopup="true" aria-expanded="false" data-v-d8fae6e2><span class="text" data-v-d8fae6e2><!----><span data-v-d8fae6e2>杂项</span><span class="vpi-chevron-down text-icon" data-v-d8fae6e2></span></span></button><div class="menu" data-v-d8fae6e2><div class="VPMenu" data-v-d8fae6e2 data-v-fcd1d7a8><div class="items" data-v-fcd1d7a8><!--[--><!--[--><div class="VPMenuLink" data-v-fcd1d7a8 data-v-acfa8338><a class="VPLink link" href="/blog/other/index" data-v-acfa8338><!--[--><span data-v-acfa8338>其他</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-fcd1d7a8 data-v-acfa8338><a class="VPLink link" href="/blog/init/index" data-v-acfa8338><!--[--><span data-v-acfa8338>初始化</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-fcd1d7a8 data-v-acfa8338><a class="VPLink link" href="/blog/pm/index" data-v-acfa8338><!--[--><span data-v-acfa8338>电源管理</span><!--]--></a></div><!--]--><!--]--></div><!--[--><!--]--></div></div></div><!--]--><!--]--></nav><!----><div class="VPNavBarAppearance appearance" data-v-8eab0e6d data-v-3f90c1a5><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" title aria-checked="false" data-v-3f90c1a5 data-v-be9742d9 data-v-b4ccac88><span class="check" data-v-b4ccac88><span class="icon" data-v-b4ccac88><!--[--><span class="vpi-sun sun" data-v-be9742d9></span><span class="vpi-moon moon" data-v-be9742d9></span><!--]--></span></span></button></div><div class="VPSocialLinks VPNavBarSocialLinks social-links" data-v-8eab0e6d data-v-ef6192dc data-v-a1a7286e><!--[--><a class="VPSocialLink no-icon" href="https://github.com/hyuuko1/blog" aria-label="github" target="_blank" rel="me noopener" data-v-a1a7286e data-v-32d78712><span class="vpi-social-github"></span></a><!--]--></div><div class="VPFlyout VPNavBarExtra extra" data-v-8eab0e6d data-v-600b50c9 data-v-d8fae6e2><button type="button" class="button" aria-haspopup="true" aria-expanded="false" aria-label="extra navigation" data-v-d8fae6e2><span class="vpi-more-horizontal icon" data-v-d8fae6e2></span></button><div class="menu" data-v-d8fae6e2><div class="VPMenu" data-v-d8fae6e2 data-v-fcd1d7a8><!----><!--[--><!--[--><!----><div class="group" data-v-600b50c9><div class="item appearance" data-v-600b50c9><p class="label" data-v-600b50c9>主题</p><div class="appearance-action" data-v-600b50c9><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" title aria-checked="false" data-v-600b50c9 data-v-be9742d9 data-v-b4ccac88><span class="check" data-v-b4ccac88><span class="icon" data-v-b4ccac88><!--[--><span class="vpi-sun sun" data-v-be9742d9></span><span class="vpi-moon moon" data-v-be9742d9></span><!--]--></span></span></button></div></div></div><div class="group" data-v-600b50c9><div class="item social-links" data-v-600b50c9><div class="VPSocialLinks social-links-list" data-v-600b50c9 data-v-a1a7286e><!--[--><a class="VPSocialLink no-icon" href="https://github.com/hyuuko1/blog" aria-label="github" target="_blank" rel="me noopener" data-v-a1a7286e data-v-32d78712><span class="vpi-social-github"></span></a><!--]--></div></div></div><!--]--><!--]--></div></div></div><!--[--><!--]--><button type="button" class="VPNavBarHamburger hamburger" aria-label="mobile navigation" aria-expanded="false" aria-controls="VPNavScreen" data-v-8eab0e6d data-v-6bee1efd><span class="container" data-v-6bee1efd><span class="top" data-v-6bee1efd></span><span class="middle" data-v-6bee1efd></span><span class="bottom" data-v-6bee1efd></span></span></button></div></div></div></div><div class="divider" data-v-8eab0e6d><div class="divider-line" data-v-8eab0e6d></div></div></div><!----></header><div class="VPLocalNav has-sidebar empty" data-v-304c8b69 data-v-5ae341c6><div class="container" data-v-5ae341c6><button class="menu" aria-expanded="false" aria-controls="VPSidebarNav" data-v-5ae341c6><span class="vpi-align-left menu-icon" data-v-5ae341c6></span><span class="menu-text" data-v-5ae341c6>菜单</span></button><div class="VPLocalNavOutlineDropdown" style="--vp-vh:0px;" data-v-5ae341c6 data-v-e28a51a6><button data-v-e28a51a6>回到顶部</button><!----></div></div></div><aside class="VPSidebar" data-v-304c8b69 data-v-46b39de1><div class="curtain" data-v-46b39de1></div><nav class="nav" id="VPSidebarNav" aria-labelledby="sidebar-aria-label" tabindex="-1" data-v-46b39de1><span class="visually-hidden" id="sidebar-aria-label" data-v-46b39de1> Sidebar Navigation </span><!--[--><!--]--><!--[--><div class="no-transition group" data-v-a84b7c21><section class="VPSidebarItem level-0 collapsible is-link" data-v-a84b7c21 data-v-6b36a2fd><div class="item" tabindex="0" data-v-6b36a2fd><div class="indicator" data-v-6b36a2fd></div><a class="VPLink link link" href="/blog/sched/index" data-v-6b36a2fd><!--[--><h2 class="text" data-v-6b36a2fd>调度</h2><!--]--></a><div class="caret" role="button" aria-label="toggle section" tabindex="0" data-v-6b36a2fd><span class="vpi-chevron-right caret-icon" data-v-6b36a2fd></span></div></div><div class="items" data-v-6b36a2fd><!--[--><div class="VPSidebarItem level-1 is-link" data-v-6b36a2fd data-v-6b36a2fd><div class="item" data-v-6b36a2fd><div class="indicator" data-v-6b36a2fd></div><a class="VPLink link link" href="/blog/sched/cfs" data-v-6b36a2fd><!--[--><p class="text" data-v-6b36a2fd>CFS</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-6b36a2fd data-v-6b36a2fd><div class="item" data-v-6b36a2fd><div class="indicator" data-v-6b36a2fd></div><a class="VPLink link link" href="/blog/sched/eevdf" data-v-6b36a2fd><!--[--><p class="text" data-v-6b36a2fd>EEVDF</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-6b36a2fd data-v-6b36a2fd><div class="item" data-v-6b36a2fd><div class="indicator" data-v-6b36a2fd></div><a class="VPLink link link" href="/blog/sched/sched_ext" data-v-6b36a2fd><!--[--><p class="text" data-v-6b36a2fd>sched_ext</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><!--]--><!--[--><!--]--></nav></aside><div class="VPContent has-sidebar" id="VPContent" data-v-304c8b69 data-v-2652e39a><div class="VPDoc has-sidebar has-aside" data-v-2652e39a data-v-d668f7cc><!--[--><!--]--><div class="container" data-v-d668f7cc><div class="aside" data-v-d668f7cc><div class="aside-curtain" data-v-d668f7cc></div><div class="aside-container" data-v-d668f7cc><div class="aside-content" data-v-d668f7cc><div class="VPDocAside" data-v-d668f7cc data-v-cb998dce><!--[--><!--]--><!--[--><!--]--><nav aria-labelledby="doc-outline-aria-label" class="VPDocAsideOutline" data-v-cb998dce data-v-c8b19031><div class="content" data-v-c8b19031><div class="outline-marker" data-v-c8b19031></div><div aria-level="2" class="outline-title" id="doc-outline-aria-label" role="heading" data-v-c8b19031>目录</div><ul class="VPDocOutlineItem root" data-v-c8b19031 data-v-63c57e50><!--[--><!--]--></ul></div></nav><!--[--><!--]--><div class="spacer" data-v-cb998dce></div><!--[--><!--]--><!----><!--[--><!--]--><!--[--><!--]--></div></div></div></div><div class="content" data-v-d668f7cc><div class="content-container" data-v-d668f7cc><!--[--><!--]--><main class="main" data-v-d668f7cc><div style="position:relative;" class="vp-doc _blog_sched_ external-link-icon-enabled" data-v-d668f7cc><div><h1 id="任务调度" tabindex="-1">任务调度 <a class="header-anchor" href="#任务调度" aria-label="Permalink to “任务调度”">​</a></h1><ul><li><a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzAxMDM0NjExNA==&amp;action=getalbum&amp;album_id=4008276724713586688" target="_blank" rel="noreferrer">任务调度器：从入门到放弃 - OPPO 内核工匠</a></li><li><a href="https://www.zhihu.com/people/yann-linux/posts" target="_blank" rel="noreferrer">Yanfei Xu - 知乎</a><ul><li><a href="https://zhuanlan.zhihu.com/p/163728119" target="_blank" rel="noreferrer">Linux 进程调度：调度时机 - 知乎</a></li><li><a href="https://zhuanlan.zhihu.com/p/400102565" target="_blank" rel="noreferrer">Linux 组调度原理 - 知乎</a></li><li><a href="https://zhuanlan.zhihu.com/p/426395078" target="_blank" rel="noreferrer">Linux 进程调度：主调度器 - 知乎</a><ul><li><code>__schedule()</code></li><li>pick_next_task()</li><li>context_switch()</li></ul></li><li><a href="https://zhuanlan.zhihu.com/p/426448579" target="_blank" rel="noreferrer">Linux 进程调度：周期性调度器 - 知乎</a><ul><li>scheduler_tick()</li></ul></li><li><a href="https://zhuanlan.zhihu.com/p/704413081" target="_blank" rel="noreferrer">Linux 内核：EEVDF 调度器详解 - 知乎</a></li></ul></li></ul><table tabindex="0"><thead><tr><th>调度类</th><th>调度策略</th><th>调度算法</th><th>调度对象</th></tr></thead><tbody><tr><td>停机调度类 stop_sched_class</td><td>无</td><td></td><td></td></tr><tr><td>限期调度类 dl_sched_class</td><td>SCHED_DEADLINE</td><td></td><td></td></tr><tr><td>实时调度类 rt_sched_class</td><td>SCHED_FIFO</td><td></td><td></td></tr><tr><td></td><td>SCHED_RR</td><td></td><td></td></tr><tr><td>公平调度类 fair_sched_class</td><td>SCHED_NORMAL</td><td></td><td></td></tr><tr><td></td><td>SCHED_BATCH</td><td></td><td></td></tr><tr><td></td><td>SCHED_IDLE</td><td></td><td></td></tr><tr><td>scx 调度类 ext_sched_class</td><td>SCHED_EXT</td><td></td><td></td></tr><tr><td>空闲调度类 idle_sched_class</td><td>无</td><td></td><td></td></tr></tbody></table><ul><li>进程优先级</li><li>调度类、调度策略、调度算法 <ul><li>进程优先级对应的权重</li><li>vruntime</li><li>调度最小粒度</li><li>调度周期</li></ul></li><li>任务分组 <ul><li>调度器的调度对象是进程或者任务组</li><li>自动分组 CONFIG_SCHED_AUTOGROUP <ul><li>struct autogroup</li><li>/proc/sys/kernel/sched_autogroup_enabled</li><li>kernel/sched/auto_group.c</li></ul></li><li>CPU 控制组 <ul><li>CONFIG_CGROUP_SCHED <ul><li>CONFIG_FAIR_GROUP_SCHED</li><li>CONFIG_RT_GROUP_SCHED</li></ul></li><li><code>echo &lt;weigth&gt; &gt; cpu.weight</code> 指定权重</li><li><code>echo &lt;pid&gt; &gt; cgroup.procs</code> 将线程组加入控制组 <ul><li>使用线程化的 cgroup，可以把同一线程组内的不同线程放入不同的控制组？</li></ul></li></ul></li></ul></li><li>数据结构 <ul><li>struct sched_class</li><li>struct rq 运行队列，percpu 的 <ul><li>包含很多个队列 <ul><li>struct dl_rq</li><li>struct rt_rq</li><li>struct cfs_rq</li><li>struct scx_rq</li></ul></li></ul></li><li>struct sched_entity 调度实体</li><li>struct task_group 任务组 <ul><li>每个任务组在每个 cpu 上都有一个公平调度实体、实时调度实体等等</li><li>每个任务组内每个 cpu 上也有一个公平调度队列、实体调度队列等等</li><li>所以，在每个 cpu 上都形成了一个 n 叉树数据结构？</li><li>特殊的 root_task_group 根任务组</li><li>计算任务组 cfs sched_entity 的权重 <code>update_cfs_group()</code><ul><li>公平调度实体的权重 = 任务组的权重 × 公平调度实体的负载比例</li><li>公平调度实体的负载比例 = 公平运行队列的权重/（任务组的平均负载 − 公平运行队列的平均负载 + 公平运行队列的权重） <ul class="contains-task-list"><li class="task-list-item"><input class="task-list-item-checkbox" disabled="" type="checkbox"> 为什么不是 公平运行队列的权重/任务组的平均负载，没看懂</li></ul></li><li>公平运行队列的权重 = 公平运行队列中所有调度实体的权重总和</li><li>任务组的平均负载 = 所有公平运行队列的平均负载的总和</li></ul></li><li>在每个处理器上，任务组的实时调度实体的调度优先级，取实时运行队列中所有实时调度实体的最高调度优先级。</li></ul></li></ul></li></ul><div class="language-cpp line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">struct</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> task_group</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">	/* 指向一个指针数组。任务组在每个 CPU 上都有一个 cfs 调度实体 */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	struct</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> sched_entity</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	**</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">se;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">	/* 指向一个指针数组。任务组在每个 CPU 上的调度实体所属的 cfs 运行队列 */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	struct</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> cfs_rq</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">		**</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">cfs_rq;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">	/* 和 cfs 一样的，不过多解释了 */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	struct</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> sched_rt_entity</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	**</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">rt_se;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	struct</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> rt_rq</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">		**</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">rt_rq;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">struct</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> sched_entity</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">	/* 在调度树中的深度 */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">				depth;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">	/* 在调度树中的父亲，也就是一个任务组 */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	struct</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> sched_entity</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">		*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">parent;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">	/* 该调度实体所属的 cfs 运行队列。如果该调度实体属于一个任务组，那么这个队列就是该任务组的队列 */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	struct</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> cfs_rq</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">			*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">cfs_rq;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">	/* 调度实体拥有的 cfs 运行队列。任务组有这个队列，进程没有，根任务组没有。*/</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	struct</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> cfs_rq</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">			*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">my_q;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br></div></div><hr><ul><li>核心函数 <code>__schedule()</code><ul><li>参数 sched_mode <ul><li>SM_IDLE</li><li>SM_NONE</li><li>SM_PREEMPT 抢占</li><li>SM_RTLOCK_WAIT</li></ul></li><li>主要过程 <ol><li>pick_next_task() 选择下一个 task</li><li>context_switch() 上下文切换 <ol class="contains-task-list"><li class="task-list-item"><input class="task-list-item-checkbox" disabled="" type="checkbox"> <code>switch_to()</code> 将来再深入。</li></ol></li></ol></li></ul></li><li>调度时机 <ul><li>进程主动调度 <ul><li>用户态 syscall sched_yield() 或者在进行其他系统调用时因等待某个资源而主动调度出去。</li><li>schedule()</li><li>cond_resched()</li><li>might_resched()</li></ul></li><li>周期调度。时钟 tick <ul><li>限期调度类的周期调度</li><li>实时调度类的周期调度</li><li>公平调度类的周期调度</li></ul></li><li>唤醒进程时，被唤醒的进程可能抢占当前进程 <ul><li>当前进程退出中断时，发生调度 irqentry_exit_cond_resched()-&gt;raw_irqentry_exit_cond_resched()-&gt;preempt_schedule_irq() <ul><li>这个中断可能是 smp_send_reschedule() 发送的 RESCHEDULE_VECTOR IPI 中断，</li></ul></li><li>唤醒指定进程 <ul><li>wake_up_process() 只会改 state 并放进 rq ？</li></ul></li><li>唤醒 wait_queue 队列里的 <ul><li>一般最后会调用到 default_wake_function()-&gt;try_to_wake_up()</li><li>有以下函数：</li><li>wake_up()</li><li>wake_up_interruptible()</li><li>...</li></ul></li><li>可能会选择正在某个 cpu 上运行着的一个受害者，让被唤醒的进程会抢占那个进程？ <ul><li>但还是得让那个进程调用到 <code>__schedule()</code> 才行？</li></ul></li></ul></li><li>创建新进程时，新进程抢占当前进程 <ul><li>wake_up_new_task() 创建新进程时。很有可能会让出当前 cpu？</li></ul></li><li>内核抢占 <ul><li>内核抢占是指当进程在内核模式下运行的时候可以被其他进程抢占。有以下抢占点：</li><li>preempt_enable() 开启抢占时 <ul><li>spin_unlock() 释放自旋锁时</li></ul></li><li>local_bh_enable() 开启软中断时</li><li>irqentry_exit()-&gt;irqentry_exit_cond_resched() 中断处理程序返回内核模式时， <ul><li>这个中断可能是别的进程 smp_send_reschedule() 发送的 IPI，也可能是时钟中断或外设中断？</li></ul></li></ul></li><li>用户抢占 <ul><li>在用户态运行时被抢占。</li><li>irqentry_exit()-&gt;irqentry_exit_to_user_mode()</li></ul></li><li>高精度时钟。</li></ul></li><li>抢占点 <ul><li>抢占。某个进程被唤醒后，给当前进程设置 <code>TIF_NEED_RESCHED</code>，并且可能发 IPI 啥的。</li></ul></li><li>各种 CONFIG <ul><li>调度抢占相关 <ul><li>CONFIG_PREEMPT_NONE: No Forced Preemption (Server) <ul><li>可以 <code>cond_resched()</code> 自愿让出，别人没法抢。</li></ul></li><li>CONFIG_PREEMPT_VOLUNTARY: Voluntary Kernel Preemption (Desktop) <ul><li>可以 <code>cond_resched()</code> 自愿让出，别人没法抢。</li><li><code>might_sleep()</code> 在此 CONFIG 下，包含了 <code>cond_resched()</code> 的作用。</li></ul></li><li>CONFIG_PREEMPT: Preemptible Kernel (Low-Latency Desktop)</li><li>CONFIG_PREEMPT_LAZY: Scheduler controlled preemption model <ul><li><a href="https://lore.kernel.org/all/20241007075055.331243614@infradead.org/" target="_blank" rel="noreferrer">https://lore.kernel.org/all/20241007075055.331243614@infradead.org/</a></li></ul></li><li>CONFIG_PREEMPT_RT: Fully Preemptible Kernel (Real-Time) <ul><li><a href="https://lore.kernel.org/all/alpine.DEB.2.21.1907172200190.1778@nanos.tec.linutronix.de/" target="_blank" rel="noreferrer">https://lore.kernel.org/all/alpine.DEB.2.21.1907172200190.1778@nanos.tec.linutronix.de/</a></li></ul></li><li>CONFIG_PREEMPT_DYNAMIC: Preemption behaviour defined on boot 允许在通过内核启动参数来选择抢占模型 <ul><li>详见 <code>__sched_dynamic_update()</code>，可以看到使用不同的抢占模型时对 cond_resched/might_resched 等函数的启用/禁用。</li></ul></li></ul></li><li>其他 <ul><li>CONFIG_SCHED_CORE</li><li>CONFIG_SCHED_CLASS_EXT</li></ul></li></ul></li><li>带宽管理 <ul><li>限期调度类的带宽管理</li><li>实时调度类的带宽管理</li><li>公平调度类的带宽管理 <ul><li>cpu cgroup</li></ul></li></ul></li><li>进程的处理器亲和性 <ul><li>系统调用 sched_setaffinity() 和 sched_getaffinity()</li><li>内核线程 kthread_bind() 和 set_cpus_allowed_ptr()</li><li>cpuset cgroup</li></ul></li><li>处理器负载均衡 <ul><li>限期调度类的处理器负载均衡</li><li>实时调度类的处理器负载均衡</li><li>公平调度类的处理器负载均衡 <ul><li>调度域和调度组</li><li>负载均衡算法</li></ul></li></ul></li><li>迁移线程</li><li>隔离处理器 <ul><li>isolcpus=</li></ul></li><li>进程的安全上下文 <ul><li>cred</li></ul></li></ul><h2 id="调度时机" tabindex="-1">调度时机 <a class="header-anchor" href="#调度时机" aria-label="Permalink to “调度时机”">​</a></h2><p>先做个总结：</p><p>调度有两种，主动调度和抢占调度。抢占调度分为两种，用户态抢占和内核态抢占。</p><ul><li>无论何种 CONFIG，都是支持用户态抢占的：中断/异常/系统调用返回用户态时，检查到 <code>_TIF_NEED_RESCHED</code> 或 <code>_TIF_NEED_RESCHED_LAZY</code> flag 就会调度。</li><li>不同的 CONFIG 对内核态抢占的支持程度不一。 <ul><li>未设置 <code>CONFIG_PREEMPTION</code>，不支持内核态抢占的 CONFIG 有： <ul><li>CONFIG_PREEMPT_NONE 只能自愿调度出去：<code>cond_resched()</code> 或 <code>schedule()</code></li><li>CONFIG_PREEMPT_VOLUNTARY 有比前者更多的自愿调度点：前者在 <code>might_sleep()</code> 中不会自愿调度</li></ul></li><li><code>CONFIG_PREEMPTION=y</code> 意味着支持内核态抢占，在设置为 =y 后，会产生这些区别： <ol><li><code>preempt_enable()/preempt_enable_notrace()/preempt_check_resched()</code> 满足一定条件时会触发调度</li><li>在内核态发生中断后，中断处理程序结束退出时 <code>irqentry_exit_cond_resched()</code> 满足一定条件时会触发调度。</li><li><code>cond_resched()</code> 和 <code>might_sleep()</code> 都不可能触发调度了。这是因为，现在，在任意满足 <code>preemptible() == true</code> 的地方，都可以直接被 <code>smp_send_reschedule()</code> 发送 IPI 中断，在中断退出时被抢占，已经不需要这两个函数了。</li><li>依赖于该 CONFIG 的有： <ul class="contains-task-list"><li>CONFIG_PREEMPT</li><li>CONFIG_PREEMPT_RT 比前者更进一步： <ol><li>“不允许被抢占的地方”更少：包括自旋锁在内的某些位置不会 <code>preempt_disable()</code> 禁止抢占</li></ol></li><li class="task-list-item"><input class="task-list-item-checkbox" disabled="" type="checkbox"> CONFIG_PREEMPT_LAZY。目的是替代 CONFIG_PREEMPT_VOLUNTARY</li></ul></li></ol></li></ul></li></ul><p>看以下几处代码就很好理解这些 CONFIG 是如何影响具体的代码逻辑的：</p><ol><li>CONFIG_PREEMPTION 对 <code>preempt_enable()/preempt_enable_notrace()/preempt_check_resched()</code> 等函数的影响</li><li><code>__sched_dynamic_update()</code> 里对几个 static call 的启用和禁用</li></ol><h3 id="主动调度-cond-resched-等函数" tabindex="-1">主动调度：<code>cond_resched()</code> 等函数 <a class="header-anchor" href="#主动调度-cond-resched-等函数" aria-label="Permalink to “主动调度：cond_resched() 等函数”">​</a></h3><ul><li><code>schedule()</code> 主动调度</li><li><code>cond_resched()</code> 满足条件时自愿调度</li><li><code>might_sleep()</code> 主要用于 debug，但是当 <code>CONFIG_PREEMPT_VOLUNTARY=y</code> 时，隐含了 <code>cond_resched()</code> 的效果</li></ul><h3 id="内核态抢占-preempt-enable-等函数" tabindex="-1">内核态抢占：<code>preempt_enable()</code> 等函数 <a class="header-anchor" href="#内核态抢占-preempt-enable-等函数" aria-label="Permalink to “内核态抢占：preempt_enable() 等函数”">​</a></h3><p><code>CONFIG_PREEMPTION=y</code> 支持内核抢占后，以下函数检查到 current task 需要被抢占，并且 <code>preemptible() == true</code> 时，就会发生调度。</p><p>调度需要满足以下条件时：</p><ol><li><code>preempt_count() == 0</code> （注意，此处不包含 PREEMPT_NEED_RESCHED）</li><li>未关闭本地中断</li></ol><p>要抢占当前运行在内核态的线程，除了要满足以上两个条件外，还需满足一个条件：</p><ol start="3"><li>current task 需要被抢占，有两种检查方式： <ol><li>thread_info 内的 TIF_NEED_RESCHED 被置位</li><li>preempt_count 内的 PREEMPT_NEED_RESCHED 被清楚</li></ol></li></ol><p><code>preempt_enable()</code> 等函数会先检查 preempt_count 的值是否为 0，一次性检查是否满足上述的第 1、3 点条件，满足条件后再去 <code>preempt_schedule()-&gt;preemptible()</code> 进一步检查。</p><p><code>CONFIG_PREEMPTION=y</code> 支持内核抢占后，当检查到满足以上条件时，就会发生调度，有以下检查点：</p><ul><li><code>preempt_enable()</code> 开抢占时检查。在内核中被大量使用： <ul><li><code>spin_unlock()</code></li><li><code>spin_trylock()</code></li><li>...</li></ul></li><li><code>preempt_enable_notrace()</code></li><li><code>preempt_check_resched()</code>，此为内部 API，主要被用于在启用 bottom-half 时检查： <ul><li><code>local_bh_enable()</code></li><li><code>spin_unlock_bh()</code></li><li><code>spin_trylock_bh()</code></li><li>...</li></ul></li></ul><h3 id="内核态抢占、用户态抢占-中断-异常处理程序退出" tabindex="-1">内核态抢占、用户态抢占：中断/异常处理程序退出 <a class="header-anchor" href="#内核态抢占、用户态抢占-中断-异常处理程序退出" aria-label="Permalink to “内核态抢占、用户态抢占：中断/异常处理程序退出”">​</a></h3><ul><li>内核态抢占：中断/异常处理程序返回到中断前的内核态上下文之前</li><li>用户态抢占：中断/异常处理程序返回到中断前的用户态上下文之前</li></ul><p>注：在 x86，中断/异常处理程序退出时都会调用 <code>irqentry_exit()</code></p><div class="language-cpp line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">irqentry_exit</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">user_mode</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(regs))</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    irqentry_exit_to_user_mode</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()-&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">exit_to_user_mode_prepare</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">      if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">unlikely</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ti_work </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> EXIT_TO_USER_MODE_WORK))</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        exit_to_user_mode_loop</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">          if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (ti_work </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (_TIF_NEED_RESCHED </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">|</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> _TIF_NEED_RESCHED_LAZY))</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">            schedule</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> /* 用户态抢占。此时不算是内核抢占，因为是在用户态被中断的 */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  else</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">regs_irqs_disabled</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(regs))</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> /* 如果发生中断时，是在内核态，而且是开中断的状态 */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">IS_ENABLED</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(CONFIG_PREEMPTION)) </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">irqentry_exit_cond_resched</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">      raw_irqentry_exit_cond_resched</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        /* TODO 这里可以改为像 preempt_enable() 中那样使用 PREEMPT_NEED_RESCHED 优化后的检查方式吗？*/</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">preempt_count</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">())</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">          if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">need_resched</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">())</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> /* 检查 TIF_NEED_RESCHED */</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">            preempt_schedule_irq</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">              __schedule</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(SM_PREEMPT);</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> /* 内核抢占 */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  else</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> /* 如果发生中断时，是在内核态，而且是关中断的状态，说明中断前是不满足内核态抢占的条件的，</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">          例如，1. 中断前是在中断处理函数中，此次中断是 nmi 中断 2. 中断前在 spin_lock_irq() 的临界区中 */</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><h3 id="用户态抢占-系统调用退出" tabindex="-1">用户态抢占：系统调用退出 <a class="header-anchor" href="#用户态抢占-系统调用退出" aria-label="Permalink to “用户态抢占：系统调用退出”">​</a></h3><p>系统调用返回时，可能发生调度</p><div class="language-cpp line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">syscall_exit_to_user_mode</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  syscall_exit_to_user_mode_work</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    exit_to_user_mode_prepare</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">      if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">unlikely</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ti_work </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> EXIT_TO_USER_MODE_WORK))</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        exit_to_user_mode_loop</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">          if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (ti_work </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (_TIF_NEED_RESCHED </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">|</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> _TIF_NEED_RESCHED_LAZY))</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">            schedule</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>中断和异常处理详见 <a href="/blog/irq/">irq/index.md</a></p><h2 id="tif-need-resched" tabindex="-1">TIF_NEED_RESCHED <a class="header-anchor" href="#tif-need-resched" aria-label="Permalink to “TIF_NEED_RESCHED”">​</a></h2><p>用于标记线程需要被重新调度。</p><h2 id="preempt-need-resched" tabindex="-1">PREEMPT_NEED_RESCHED <a class="header-anchor" href="#preempt-need-resched" aria-label="Permalink to “PREEMPT_NEED_RESCHED”">​</a></h2><p>也用于标记线程需要被重新调度。</p><p>是一个小优化，先看看 AI 的讲解 <a href="./PREEMPT_NEED_RESCHED">PREEMPT_NEED_RESCHED</a>（不完全正确）。</p><p>邮件讨论：</p><ul><li><a href="https://lore.kernel.org/lkml/20130814131539.790947874@chello.nl/" target="_blank" rel="noreferrer">[RFC][PATCH 0/5] preempt_count rework - Peter Zijlstra</a></li><li><a href="https://lore.kernel.org/lkml/20130917082838.218329307@infradead.org/" target="_blank" rel="noreferrer">[PATCH 00/11] preempt_count rework -v3 - Peter Zijlstra</a> <br> 主要做了两个对 <code>preempt_enable()</code> 的优化。还展示了优化前后的汇编指令对比。 <ol><li><code>f27dde8deef3</code> 2013-09-25 sched: Add NEED_RESCHED to the preempt_count <br> 将 preempt_count（是否允许抢占）和 need_resched（是否需要抢占）两个检查 fold 为一个，这样一来，<code>preempt_enable()</code> 只需要在 preempt_count -1 后检查其是否为 0，无需检查 current 的 <code>TIF_NEED_RESCHED</code> flag。 <br> 实现原理：让 <code>PREEMPT_NEED_RESCHED</code> 作为 <code>TIF_NEED_RESCHED</code> 在 preempt_count 里的“影子”： <ol><li>让 preempt_count 的初始值就默认包含 <code>PREEMPT_NEED_RESCHED</code></li><li>当 current task 需要被 resched 时，就清除 <code>PREEMPT_NEED_RESCHED</code></li></ol></li><li><code>c2daa3bed53a</code> 2013-09-25 sched, x86: Provide a per-cpu preempt_count implementation <br> x86 使用 per-cpu 的 preempt_count，相比于通过 thread_info 访问，要更快一些。</li></ol></li><li><a href="https://lore.kernel.org/lkml/tip-7a7m5qqbn5pmwnd4wko9u6da@git.kernel.org/" target="_blank" rel="noreferrer">[tip:sched/core] sched: Add NEED_RESCHED to the preempt_count - tip-bot for Peter Zijlstra</a></li></ul><p>其他的一些个人理解，不一定对：</p><ul><li>对 preempt_count 的修改频率极高，要避免对 preempt_count 进行 atomic 操作，所以现在没有提供 remotely 修改 preempt_count 的 API（初始化操作除外，只能被当前的 cpu 访问（虽然强行用 per_cpu() 也能访问）。</li></ul><h2 id="关于-might-sleep" tabindex="-1">关于 might_sleep() <a class="header-anchor" href="#关于-might-sleep" aria-label="Permalink to “关于 might_sleep()”">​</a></h2><p>在开启 CONFIG_DEBUG_ATOMIC_SLEEP 时，might_sleep() 比 might_resched() 多了一些检测，在未开启时，这两个并无区别。因此，使用 might_sleep() 而非 might_resched()，后者只是一个内部接口。</p><p>那 might_sleep() 和 cond_resched() 是什么区别呢？</p><ul><li>在开启 CONFIG_DEBUG_ATOMIC_SLEEP 时，前者比后者多了一个 WARN，有助于尽早发现问题。</li><li>在 CONFIG_PREEMPT_NONE 时，前者不生效，后者生效，其他 CONFIG 时，二者行为一致。</li><li>前者用于提示：后面的操作可能发生调度。本身也有自愿调度的作用，但并不是其主要用途。 <ul class="contains-task-list"><li class="task-list-item"><input class="task-list-item-checkbox" disabled="" type="checkbox"> 我觉得不应该让 might_sleep() 有主动调度的作用啊，应该只保留 debug 提示的作用，因为后面可能就马上要发生调度了。而且如果此时调度，那么可能就导致可能会立即成功的 wait_event() 之类的更晚执行了，导致延迟变高？</li></ul></li><li>后者一般在很耗时且不会调度出去的 while 循环中使用，增加自愿调度点，防止非抢占式内核里一直占着 cpu，造成软死锁。</li></ul><hr><p>比较关键的一些函数，先记在这里，</p><ul><li>wakeup_preempt()</li><li>resched_curr() 和 resched_curr_lazy()</li><li>pick_next_task()</li></ul><h2 id="schedule" tabindex="-1"><code>__schedule()</code> <a class="header-anchor" href="#schedule" aria-label="Permalink to “__schedule()”">​</a></h2><p><code>__schedule()</code> 函数的注释，翻译一下：</p><p>驱使调度器运行并因此进入本函数的主要途径如下：</p><ol><li>显式阻塞（Explicit blocking）： 例如互斥锁（mutex）、信号量（semaphore）、等待队列（waitqueue）等机制。</li><li>在中断返回和用户空间返回路径上检查 TIF_NEED_RESCHED 标志： 例如调度器会在定时器中断处理函数 sched_tick() 中设置该标志。</li><li>唤醒（Wakeups）本身并不会直接导致进入 schedule()，它们只是将一个任务添加到 run-queue 中，仅此而已。 不过，如果新加入运行队列的任务抢占了当前任务（例如优先级更高），那么唤醒操作会设置 TIF_NEED_RESCHED 标志，并且 schedule() 会在最近的可能时机被调用： <ul><li>如果内核是可抢占的（CONFIG_PREEMPTION=y）： <ul><li>在系统调用或异常上下文中，发生在下一次最外层的 preempt_enable() 调用时。（这甚至可能快到就在 wake_up() 内部释放自旋锁 spin_unlock() 的那一刻！）</li><li>在中断（IRQ）上下文中，发生在从中断处理函数返回到可抢占上下文（内核态）的时候。</li></ul></li><li>如果内核是不可抢占的（未设置 CONFIG_PREEMPTION），则发生在下述最近的时间点： <ul><li>调用 cond_resched() 时</li><li>显式调用 schedule() 时</li><li>从系统调用或异常返回用户空间时</li><li>从中断处理函数返回用户空间时</li></ul></li></ul></li></ol><hr><p>进入 <code>__schedule()</code> 时，必须是关抢占的， 这是为了防止重入这个函数？因为如果此时发生中断，可能在中断返回路径上又进这个函数</p><hr><p>注释里没提到，但我觉得还存在的一个约束是：进入 <code>__schedule()</code> 时，必须是开中断的。 我这样推断的理由：</p><ol><li><code>__schedule()</code> 里会先 <code>local_irq_disable()</code> 然后在 <code>context_switch()-&gt;switch_to()</code> 结束后，等到下一次调度回来时，在 <code>context_switch()-&gt;finish_task_switch()-&gt;finish_lock_switch()-&gt;raw_spin_rq_unlock_irq()-&gt;local_irq_enable()</code> 开启中断，因此离开 <code>__schedule()</code> 时一定是开中断的。</li><li><code>__cond_resched()</code> 里如果检测到是 <code>irqs_disabled()</code>，则不会进入 <code>preempt_schedule_common()-&gt;__schedule()</code></li><li>只用于中断处理函数返回用户态时的 <code>preempt_schedule_irq()</code> 会先 <code>local_irq_enable()</code> 再 <code>__schedule()</code></li><li>只用于中断处理函数返回内核态时的 <code>exit_to_user_mode_loop()</code> 会先 <code>local_irq_enable_exit_to_user()-&gt;local_irq_enable()</code> 再 <code>schedule()</code></li><li><code>__might_resched()</code> 里如果检测到 <code>irqs_disabled()</code>，会产生报错日志。</li></ol><hr><p>现在来看看主要流程吧：</p><div class="language-cpp line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">__schedule</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> sched_mode)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  /* 关闭中断，我觉得是因为中断上下文也有可能获取 rq-&gt;__lock 造成死锁 */</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  local_irq_disable</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  /* 其他 cpu 此时可能也在操作当前 cpu 的 rq 数据</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> //XXX 主要是负载均衡相关的代码？  */</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  rq_lock</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(rq, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">rf);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  next </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> pick_next_task</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(rq, rq-&gt;donor, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">rf);</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  clear_tsk_need_resched</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(prev);</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> /* 清除 _TIF_NEED_RESCHED | _TIF_NEED_RESCHED_LAZY */</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  clear_preempt_need_resched</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> /* 清楚 preempt_count 里的 PREEMPT_NEED_RESCHED */</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  context_switch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(rq, prev, next, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">rf);</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    switch_to</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()-&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">__switch_to_asm</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()-&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">__switch_to</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">      raw_cpu_write</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(current_task, next_p);</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> /* 修改 percpu 的 current() */</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><hr><p>疑问</p><ul class="contains-task-list"><li class="task-list-item"><input class="task-list-item-checkbox" disabled="" type="checkbox"> cfs 和 eevdf 都是 fair_sched_class 的实现？cfs 已被 eevdf 取代，现在的代码里只有 eevdf 没有 cfs？</li></ul><hr><p>TODO</p><ul class="contains-task-list"><li class="task-list-item"><input class="task-list-item-checkbox" disabled="" type="checkbox"> CONFIG_SCHED_PROXY_EXEC 代理执行，和 RT 以及 SCHED_EXT 不能共存。</li><li class="task-list-item"><input class="task-list-item-checkbox" disabled="" type="checkbox"> 《趣谈 Linux 操作系统》</li></ul></div></div></main><footer class="VPDocFooter" data-v-d668f7cc data-v-1bcd8184><!--[--><!--]--><div class="edit-info" data-v-1bcd8184><div class="edit-link" data-v-1bcd8184><a class="VPLink link vp-external-link-icon no-icon edit-link-button" href="https://github.com/hyuuko1/blog/edit/main/sched/index.md" target="_blank" rel="noreferrer" data-v-1bcd8184><!--[--><span class="vpi-square-pen edit-link-icon" data-v-1bcd8184></span> Edit this page<!--]--></a></div><div class="last-updated" data-v-1bcd8184><p class="VPLastUpdated" data-v-1bcd8184 data-v-73dafb42>最后更新于: <time datetime="2025-11-23T15:44:07.000Z" data-v-73dafb42></time></p></div></div><nav class="prev-next" aria-labelledby="doc-footer-aria-label" data-v-1bcd8184><span class="visually-hidden" id="doc-footer-aria-label" data-v-1bcd8184>Pager</span><div class="pager" data-v-1bcd8184><!----></div><div class="pager" data-v-1bcd8184><a class="VPLink link pager-link next" href="/blog/sched/index" data-v-1bcd8184><!--[--><span class="desc" data-v-1bcd8184>下一页</span><span class="title" data-v-1bcd8184>调度</span><!--]--></a></div></nav></footer><!--[--><!--]--></div></div></div><!--[--><!--]--></div></div><footer class="VPFooter has-sidebar" data-v-304c8b69 data-v-5b9946f5><div class="container" data-v-5b9946f5><p class="message" data-v-5b9946f5>Licensed under MIT</p><p class="copyright" data-v-5b9946f5>Copyright © 2024-2025 HYUUKO</p></div></footer><!--[--><!--]--></div></div>
    
    
  </body>
</html>